{
    "version": "https://jsonfeed.org/version/1",
    "title": "橙熟 • All posts by \"面试\" category",
    "description": "我的笔记",
    "home_page_url": "https://ooooddddd.github.io",
    "items": [
        {
            "id": "https://ooooddddd.github.io/2024/01/03/%E8%B1%86%E4%B8%81%E7%82%B9%E8%AF%84%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/%E8%B1%86%E4%B8%81%E7%82%B9%E8%AF%84%E7%9B%B8%E5%85%B3/",
            "title": "豆丁点评相关",
            "date_published": "2024-01-03T12:06:12.000Z",
            "content_html": "<pre><code>基于Redis + Spring Boot实现的类点评APP，实现了用户登录、查询店铺、优惠券秒杀、发表点评、推送点评、附近商户、用户签到的完整业务流程。\n</code></pre>\n<p>项目的难点：主要是事务的问题</p>\n<h3 id=\"用户登陆：\"><a href=\"#用户登陆：\" class=\"headerlink\" title=\"用户登陆：\"></a><strong>用户登陆</strong>：</h3><p>使用 Redis 实现分布式 Session，解决集群间登录态同步问题；使用 Hash 代替 String 来存储用户信息，节约内存的同时有利于单个字段的修改。</p>\n<p><strong>科室查询</strong>：将高访问量的科室信息提前缓存到了redis中，降低数据库压力的同时提高了查询性能。同时，为了之后方便其他业务使用缓存功能，使用<strong>泛型 + 函数式</strong>编程实现了通用缓存的静态方法，并解决了</p>\n<ol>\n<li><strong>缓存穿透</strong>（用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力），是通过缓存 <strong>null</strong> 值解决，但是会浪费内存空间，所以后续准备改为布隆过滤器</li>\n<li><strong>缓存雪崩</strong>（指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。）：<ul>\n<li>在原有的失效时间的基础上添加一个随机值(1-5分钟)</li>\n<li>搭建redis集群提高服务的高可用性</li>\n<li>多级缓存</li>\n<li>降级限流策略</li>\n</ul>\n</li>\n<li><strong>缓存击穿（热点Key问题）</strong>【被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。】（利用<strong>互斥锁</strong>或者<strong>逻辑过期</strong>实现）<ol>\n<li>逻辑过期时间（不保证一致性，适用于注重用户体验，而非注重数据一致性的场景）：先从redis中查询缓存，如果未命中，直接返回 null，如果命中，判断其逻辑过期时间是否过期，未过期，直接返回数据。已过期，则需要进行缓存重建，先尝试获取互斥锁，获取成功，开启独立线程去完成缓存重建的工作。如果获取互斥锁失败，则不进行等待，直接返回已经过期的数据即可。性能较好。</li>\n</ol>\n</li>\n<li>双写一致性</li>\n</ol>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231229142644881.png\" alt=\"image-20231229142644881\"></p>\n<h3 id=\"优惠券秒杀功能：\"><a href=\"#优惠券秒杀功能：\" class=\"headerlink\" title=\"优惠券秒杀功能：\"></a><strong>优惠券秒杀功能</strong>：</h3><p>使用Redis + Lua脚本实现对用户下单资格的预检，同时用乐观锁解决预约下单产生的超号问题。</p>\n<p>乐观锁：不加锁，在更新时判断是否有其他线程在修改（性能好，但成功率低）</p>\n<ol>\n<li>版本号法：额外记录一个 version 值，在扣减库存的同时变化这个值，通过这个值是否变化来检验</li>\n<li>库存直接作为版本号，在更新时加一条对库存的判断</li>\n</ol>\n<p>使用Redisson分布式锁解决了在集群模式下一人一单的线程安全问题。</p>\n<ol>\n<li>首先是想通过加 synchronized 锁来解决一人一单，将 synchronized 锁加到方法的外面，先获取锁，再通过代理对象去提交事务，最后释放锁，是线程安全的。但这样操作又会出现 spring 事务失效的问题，因此需要先获取事务的代理对象，然后再使用代理对象去调用方法。需要在spingboot的启动类上面添加@EnableAspectJAutoProxy(exposeProxy &#x3D; true)注解。</li>\n<li>但是这个synchronized 锁在分布式集群模式下，会失效，因为synchronized关键字的作用域其实是一个进程，在这个进程下面的所有线程都能够进行加锁，但是在集群模式下属于多台服务器，多进程</li>\n<li>通过使用Redisson提供的锁对象，利用 userId创建锁对象，来控制一人一单。</li>\n</ol>\n<h4 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h4><p>使用Redis Stream结构作为消息队列，实现异步预约下单功能。</p>\n<p>使用阻塞队列也可以完成异步下单的功能，但是会存在几个问题：</p>\n<ol>\n<li>基于 jvm 的阻塞队列存在内存限制的问题</li>\n<li>数据丢失问题：当jvm重启或宕机，阻塞队列中的所有信息都会丢失</li>\n<li>同时，当该订单从阻塞队列中取出后，在处理的过程中发生了异常，则这个订单就永远无法处理了</li>\n</ol>\n<p>因此可以利用 Redis Stream 消息队列解决上面存在的几个问题，Stream类型的消息队列的特点</p>\n<ol>\n<li>消息可回溯</li>\n<li>一个消息可以被多个消费者读取</li>\n<li>可以阻塞读取</li>\n<li>但是有消息漏读的风险</li>\n</ol>\n<p>过程：依然是通过 Lua 脚本进行 判断秒杀优惠券库存和校验一人一单的功能，如果校验成功，则发送消息到消息队列中，并且初始化一个代理对象，这个代理对象可以进行创建订单的功能。</p>\n<p>然后通过一个线程池去不断去消费消息队列中的消息，即使发生异常（消息已取出但未消费）的消息会持久化到PendingList中，后续通过获取pending-list中的订单信息，依然可以将其消费掉。然后跳出 handlePendingList的方法，继续去处理正常的消息队列。最后创建订单，并且通过 SACK 命令确认消息已处理。</p>\n<h3 id=\"探店笔记点赞排行\"><a href=\"#探店笔记点赞排行\" class=\"headerlink\" title=\"探店笔记点赞排行\"></a><strong>探店笔记</strong>点赞排行</h3><p>使用 Redis List 数据结构存储用户点赞信息，并基于 ZSet 实现 TopN 点赞排行</p>\n<h3 id=\"推送点评\"><a href=\"#推送点评\" class=\"headerlink\" title=\"推送点评\"></a>推送点评</h3><p>feed流，使用的是推模式，后续随着用户量的增加，可以将其改为推拉结合，活跃粉丝使用推模式，而普通粉丝则使用拉模式。</p>\n<h3 id=\"附近商户\"><a href=\"#附近商户\" class=\"headerlink\" title=\"附近商户\"></a>附近商户</h3><p>使用了redis中的geo数据结构，根据经纬度坐标信息存储商户的地理位置，并使用 Geo Search 命令实现高性能商户查询及按距离排序。</p>\n<h3 id=\"用户签到\"><a href=\"#用户签到\" class=\"headerlink\" title=\"用户签到\"></a>用户签到</h3><p>使用到了Redis的BitMap数据统计功能，利用bitmap，计算今天是本月的第几天，就将对应bit位置1.</p>\n<p>后续计划根据用户签到送出激励计划，用户签到赠送橙币，可以使用橙币在购买优惠券时抵扣现金。</p>\n",
            "tags": [
                "点评"
            ]
        },
        {
            "id": "https://ooooddddd.github.io/2024/01/03/Spring%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/Spring%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/",
            "title": "Spring框架相关",
            "date_published": "2024-01-03T12:02:34.000Z",
            "content_html": "<h3 id=\"一、IOC和AOP\"><a href=\"#一、IOC和AOP\" class=\"headerlink\" title=\"一、IOC和AOP\"></a>一、IOC和AOP</h3><h4 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h4><ol>\n<li>控制翻转，IOC指的是将对象的创建和依赖注入由应用代码转移到了Spring容器中，原本需要程序员手动创建对象，依赖，现在翻转给了Spring帮忙实现。降低了应用代码的复杂度，提高了代码的可重用性和可维护性。</li>\n<li>BeanFactory就是IOC容器，由容器进行创建Bean对象</li>\n</ol>\n<h4 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h4><p>面向切面编程，正常来说，我们的代码中不仅需要业务逻辑部分，还需要日志，安全，事务等，但是如果有个业务需要经常用到，就比如说登陆校验吧，用户可能在看购物车需要校验其是否登陆，在看订单信息也需要校验是否登陆，如果使用AOP将这个校验的逻辑抽离出来，实现一个全局统一登陆校验，就不用再每个方法里面单独进行校验了。</p>\n<h3 id=\"二、IOC的实现机制\"><a href=\"#二、IOC的实现机制\" class=\"headerlink\" title=\"二、IOC的实现机制\"></a>二、IOC的实现机制</h3><ol>\n<li>定义Bean：在Spring IOC中，所有的对象都被看作是Bean，需要在配置文件使用注解的方式中进行定义和配置</li>\n<li>创建Bean工厂，在Spring 中，BeanFactory 负责管理Bean的创建、组装和销毁等任务。Spring IOC 容器就是Bean工厂的一种实现。</li>\n<li>读取配置文件：Spring IOC 容器会读取配置文件或者使用注解的方式来获取Bean的定义和配置信息</li>\n<li>创建Bean实例：根据配置文件相关信息通过反射技术来创建Bean的实例，并保存到容器中</li>\n<li>组装Bean：Spring IOC 容器根据配置文件中的信息，将不同的Bean实例组装起来，形成一个完整的应用程序。</li>\n<li>注入依赖：根据配置文件的信息，自动为Bean注入依赖的对象或者值</li>\n<li>提供Bean实例：通过Spring IOC 容器获取需要的Bean实例，从而调用其中的方法或者属性等。</li>\n</ol>\n<h4 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h4><p>创建的过程：首先实例化Bean，并设置Bean的属性，根据其实现的Aware接口设置依赖信息，接下来会陆续调用一些方法：</p>\n<ol>\n<li>BeanPostProcess的postProcessBeforeInitialization方法，完成初始化前的自定义操作</li>\n<li>afterPropertiesSet方法做一些属性被设定后的自定义操作</li>\n<li>调用Bean的Init方法，做一些初始化相关操作</li>\n<li>然后再调用postProcessAfterInitialization去完成bean初始化之后的相关自定义操作。这四个方法类似于AOP</li>\n</ol>\n<p>此时，Bean初始化完成，可以使用这个Bean了</p>\n<p>销毁过程：调用DisposableBean的destory()方法，如果实现了自定义的销毁方法，也去调用。其中单例Bean会随着容器的销毁而销毁，多例的Bean则是通过JVM里的垃圾回收器负责回收的。</p>\n<h3 id=\"三、Spring框架中的设计模式\"><a href=\"#三、Spring框架中的设计模式\" class=\"headerlink\" title=\"三、Spring框架中的设计模式\"></a>三、Spring框架中的设计模式</h3><ul>\n<li>单例模式：Spring中的Bean默认是单例模式，每个对象实例只创建一次</li>\n<li>工厂模式：Spring使用工厂模式通过BeanFactory创建并管理Bean</li>\n<li>代理模式：Spring Aop基于动态代理技术，使用代理模式实现切面编程</li>\n</ul>\n<h3 id=\"四、-Autowired-和-Resources的区别\"><a href=\"#四、-Autowired-和-Resources的区别\" class=\"headerlink\" title=\"四、@Autowired 和 @Resources的区别\"></a>四、@Autowired 和 @Resources的区别</h3><ul>\n<li>@Autowired：Spring框架的注入Bean的注解，默认的注入方式是ByType（根据类型进行匹配），当一个接口存在多个实现类时，需要通过@Qualifier注解来指定名称。支持在构造函数、方法、字段和参数上使用。</li>\n<li>@Resources：jdk提供的注解注入方式，默认是ByName（根据名称进行匹配），如果一个接口有多个实现类，可以通过name属性显式指定名称。主要用于字段和方法的注入，不支持在构造函数上使用。</li>\n</ul>\n<h3 id=\"五、Spring处理线程并发问题，ThreadLocal\"><a href=\"#五、Spring处理线程并发问题，ThreadLocal\" class=\"headerlink\" title=\"五、Spring处理线程并发问题，ThreadLocal\"></a>五、Spring处理线程并发问题，ThreadLocal</h3><p>ThreadLocal类：提供了线程本地变量的功能，可以让每个线程拥有自己的<strong>变量副本</strong>，从而避免了多个线程之间的共享问题。但是ThreadLocal使用时需要注意<strong>内存泄漏</strong>的问题。</p>\n<p>在豆丁点评项目中，用户登陆之后，将用户的脱敏信息通过set方法存放到了ThreadLocal中，使用时可以通过get方法获取，退出登录时使用remove方法将其移除。</p>\n<p><strong>原理：</strong>首选，Thread类中存在两个ThreadLocalMap类型的变量，可以将ThreadLocalMap理解为ThreadLocal类实现的定制化HashMap。最终的变量是存储在了当前线程的ThreadLocalMap中，并不是ThreadLocal上，ThreadLocalMap可以存储以ThreadLocal为 key，Object对象为value的键值对。</p>\n<p><strong>内存泄露问题：</strong>ThreadLocalMap中的Key是ThreadLocal的弱引用，而value是强引用。所有在垃圾回收时，key被清理掉时，value不会被清理。此时ThreadLocalMap中就会出现key为null的Entry，如果不做任何措施，value无法被GC回收，此时就会出现内存泄漏。因此ThreadLocalMap在调用set，get和remove方法的时候，会主动清理key为null的记录。</p>\n<h3 id=\"六、Spring-⽀持哪⼏种事务管理类型\"><a href=\"#六、Spring-⽀持哪⼏种事务管理类型\" class=\"headerlink\" title=\"六、Spring ⽀持哪⼏种事务管理类型\"></a>六、Spring ⽀持哪⼏种事务管理类型</h3><ol>\n<li>编程式事务管理</li>\n<li>声明式事务管理：</li>\n<li>注解式事务管理：@Transactional注解</li>\n</ol>\n<h3 id=\"七、Spring-Boot-的主要优点\"><a href=\"#七、Spring-Boot-的主要优点\" class=\"headerlink\" title=\"七、Spring Boot 的主要优点\"></a>七、Spring Boot 的主要优点</h3><ol>\n<li>开发基于Spring的应用程序简单多了，提高了整体的开发速度</li>\n<li>Spring Boot 不需要编写大量的xml配置</li>\n<li>Spring Boot 提供嵌入式HTTP服务器，如Tomcat，可以更加轻松地开发web应用程序</li>\n<li>Spring Boot Starters 是⼀系列依赖关系的集合，因为它的存在，项⽬的依赖之 间的关系对我们来说变的更加简单了</li>\n</ol>\n<h3 id=\"八、-SpringBootApplication注解\"><a href=\"#八、-SpringBootApplication注解\" class=\"headerlink\" title=\"八、@SpringBootApplication注解\"></a>八、@SpringBootApplication注解</h3><ol>\n<li>可以把SpringBootApplication注解看作是@Configuration、@EnableAutoConfiguration、@ComponentScan三个注解的集合。</li>\n<li>@EnableAutoConfiguration注解：开启SpringBoot的自动配置机制</li>\n<li>@ComponentScan：扫描被@Component（Service、controller、Repository）注解修饰的Bean，注解默认会扫描该类所在的包下的所有的类</li>\n<li>@Configuration：允许Spring上下文中注册额外的bean或者导入其他配置类。</li>\n</ol>\n<h3 id=\"九、开发-RESTful-Web-服务常⽤的注解有哪些\"><a href=\"#九、开发-RESTful-Web-服务常⽤的注解有哪些\" class=\"headerlink\" title=\"九、开发 RESTful Web 服务常⽤的注解有哪些\"></a>九、开发 RESTful Web 服务常⽤的注解有哪些</h3><h4 id=\"RESTful-风格是什么\"><a href=\"#RESTful-风格是什么\" class=\"headerlink\" title=\"RESTful 风格是什么\"></a>RESTful 风格是什么</h4><p>简单来讲就是：RESTful API 可以让程序员看到 URL+Http Method 就知道这个URL是干什么的，看到了响应码，就知道请求结果是怎样的。</p>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231228102018854.png\" alt=\"image-20231228102018854\"></p>\n<h4 id=\"Spring-Bean相关\"><a href=\"#Spring-Bean相关\" class=\"headerlink\" title=\"Spring Bean相关\"></a>Spring Bean相关</h4><ul>\n<li>@Autowired：自动注入对象到类中进行使用，被注入的类需要被Spring容器进行管理</li>\n<li>@RestController：表示这是一个控制器Bean，并且将函数的返回值直接填入Http响应体中，是Rest风格的控制器</li>\n</ul>\n<h4 id=\"处理HTTP请求\"><a href=\"#处理HTTP请求\" class=\"headerlink\" title=\"处理HTTP请求\"></a>处理HTTP请求</h4><ul>\n<li>@GetMapping：get请求，请求参数是放在了路径url中，不太安全，并且会受到url长度的限制，get一般用于资源的获取，读取数据。</li>\n<li>@PostMapping：post请求，通过request body传递参数，可传递的数据类型更多，更安全。post一般用于修改和写入数据。</li>\n<li>@PutMapping：put请求</li>\n<li>@DeleteMapping：delete请求</li>\n</ul>\n<h4 id=\"前后端传递值\"><a href=\"#前后端传递值\" class=\"headerlink\" title=\"前后端传递值\"></a>前后端传递值</h4><ul>\n<li><p>@PathVariable 和 @RequestParam，PathVariable用于获取路径参数，@RequestParam用于获取查询参数</p>\n<ul>\n<li><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231228104008749.png\" alt=\"image-20231228104008749\"></li>\n</ul>\n</li>\n<li><p>@RequestBody，用于读取一个Json格式的数据，并将其绑定到一个Java对象上去。一个方法只能有一个@RequestBody，但可以有多个**<code>@RequestParam</code>和<code>@PathVariable</code>**</p>\n</li>\n</ul>\n",
            "tags": [
                "Spring"
            ]
        },
        {
            "id": "https://ooooddddd.github.io/2024/01/03/Javase%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/Javase%E7%9B%B8%E5%85%B3/",
            "title": "Javase相关",
            "date_published": "2024-01-03T12:00:41.000Z",
            "content_html": "<h3 id=\"一、Java常用类\"><a href=\"#一、Java常用类\" class=\"headerlink\" title=\"一、Java常用类\"></a>一、Java常用类</h3><h4 id=\"1、Java的八大基本数据类型\"><a href=\"#1、Java的八大基本数据类型\" class=\"headerlink\" title=\"1、Java的八大基本数据类型\"></a>1、Java的八大基本数据类型</h4><ol>\n<li>整数：byte、short、int、long</li>\n<li>浮点数：float、double</li>\n<li>布尔：boolearn</li>\n<li>字符：char</li>\n</ol>\n<h4 id=\"2、ArrayList和linkedlist的区别\"><a href=\"#2、ArrayList和linkedlist的区别\" class=\"headerlink\" title=\"2、ArrayList和linkedlist的区别\"></a>2、ArrayList和linkedlist的区别</h4><ol>\n<li>都是线程不安全的</li>\n<li>底层数据结构：ArrayList使用的是Object数组；linkedlist底层使用的是双向循环链表</li>\n<li>插入删除：ArrayList采用的是数组存储，因此在插入和删除时的时间复杂度会受到元素位置的影响。而LinkedList则近似于O(1)</li>\n<li>是否支持快速随机访问：LinkedList不支持，而ArrayList则可以通过元素的序号快速获取元素对象。</li>\n<li>内存空间占用：ArrayList的空间浪费主要体现在list列表的末尾需要预留一定的冗余空间。而LinkedList则是需要额外存储直接后继与直接前驱。</li>\n</ol>\n<h4 id=\"3、ArrayList扩容\"><a href=\"#3、ArrayList扩容\" class=\"headerlink\" title=\"3、ArrayList扩容\"></a>3、ArrayList扩容</h4><p>以<strong>无参构造方法</strong>创建一个ArrayList时，是不会分配容量的，默认是<strong>0</strong>，只有在向ArrayList中add()第一个元素时，容量会得到扩容，默认为<strong>10</strong>，然后继续向里面添加元素，到<strong>11个</strong>元素时，此时已经超出当前容量，会进行扩容，10+10&#x2F;2&#x3D;15，当old容量为偶数时，新容量刚好就是old容量的1.5倍，奇数则会损失0.5的小数点。</p>\n<h4 id=\"4、HashMap-的-7-种遍历方式与性能分析\"><a href=\"#4、HashMap-的-7-种遍历方式与性能分析\" class=\"headerlink\" title=\"4、HashMap 的 7 种遍历方式与性能分析\"></a>4、HashMap 的 7 种遍历方式与性能分析</h4><ol>\n<li>迭代器:Iterator EntrySet、Iterator KeySet</li>\n<li>For Each:For EntrySet， For KeySet</li>\n<li>Lambda表达式</li>\n<li>Streams API</li>\n<li>多线程Streams API</li>\n</ol>\n<p>EntrySet的遍历性能最好，因为KeySet在循环时使用了map.get(key)，相当于又遍历了以便Map集合去查询Key所对应的值。在使用迭代器或者for循环时，其实已经遍历了一遍Map集合了。EntrySet只需要遍历一遍，然后就将对象的Key和Value都存放在了Entry对象中，因此再获取Key和Value就无需再遍历Map集合了</p>\n<p><strong>EntrySet</strong>：</p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">*</span><span class=\"token comment\">// 遍历*</span>\n   <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> entry <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p><strong>KeySet：</strong></p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">Integer</span> key <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h4 id=\"5、hashmap是否是线程安全的，常见的线程安全的集合\"><a href=\"#5、hashmap是否是线程安全的，常见的线程安全的集合\" class=\"headerlink\" title=\"5、hashmap是否是线程安全的，常见的线程安全的集合\"></a>5、hashmap是否是线程安全的，常见的线程安全的集合</h4><p>hashmap是线程不安全的，多线程下进行扩容会导致死循环，jdk1.7中hashmap的链表使用头插法插入元素，扩容时可能会导致环形链表的出现形成死循环，因此jdk1.8改为了尾插法，但是多线程的put操作，可能会导致元素的丢失问题。</p>\n<p>常见的线程安全的集合：</p>\n<p>hashtable，concurrentHashMap，vector、Stack。</p>\n<h4 id=\"6、HashMap的底层原理\"><a href=\"#6、HashMap的底层原理\" class=\"headerlink\" title=\"6、HashMap的底层原理\"></a>6、HashMap的底层原理</h4><p>在JDK1.8之前hashMap的底层数据结构是由数组+链表组成的，数组是HashMap的主体部分，而链表是为了解决哈希冲突而存在的。在JDK1.8中，是由数组+链表+红黑树组成的，当链表过长时，会严重影响HashMap的性能，因为链表的搜索时间复杂度是O（n），而红黑树则是O(logN)。因此，JDK1.8中引入了红黑树，在链表达到一定条件是会转化为红黑树。这个条件就是：当链表长度大于8，就会去检查数组的长度是否大于64，如果数组长度小于64，则进行数组的扩容，否则就会将链表转化为红黑树，以减少搜索时间。HashMap中采用的解决hash冲突的办法是链地址法。将哈希值相同的元素构成一个单链表，并将单链表的头结点存放在哈希表的第i个单元中。HashMap的默认加载因子是0.75，初始化数组的长度默认值是16，threshold是hashmap所能容纳的最大键值对数量&#x3D;加载因子*数组长度，当容量达到这个值时，数组就会进行扩容，扩大为原来的两倍，并将原来的对象放入新数组中。这里jdk1.8进行了适当的优化，无需再重新计算hash值，元素的位置在原来的位置或者是原来的位置+oldCap。</p>\n<p>jdk1.8之前，hashmap的插入方法是头插法，新插入的元素会插入到链表的头部。产生的问题如下：</p>\n<ul>\n<li>破坏了链表元素的插入顺序，可能不利于某些需要按照插入顺序进行遍历的场景</li>\n<li>容易形成环形链表的问题：由于头插法需要修改链表头，在多线程环境下可能会引起链表环形的问题，使得链表遍历时出现死循环</li>\n</ul>\n<h4 id=\"7、ConCurrentHashMap底层原理\"><a href=\"#7、ConCurrentHashMap底层原理\" class=\"headerlink\" title=\"7、ConCurrentHashMap底层原理\"></a>7、ConCurrentHashMap底层原理</h4><ol>\n<li>ConCurrentHashMap在HashMap的基础上加上的锁的机制，因此是线程安全的。在JDK1.7中，ConCurrentHashMap是由Segment分段数组结构和HashEntry数组结构组成的。即ConCurrentHashMap把哈希表分为了多个Segment小数组，而每个Segment就是一个类似于hashmap的结构，每一个hashmap的内部可以进行扩容，而segment的个数一旦初始化就不能再改变，默认值是16，也就可以认为其默认支持16个线程的并发。</li>\n<li>在jdk1.8中，其数据结构变成了数组+链表&#x2F;红黑树的组合，当链表冲突达到一定长度时，会转化为红黑树。在锁的实现上，抛弃了原本的Segment分段锁，采用了CAS + synchronized 对链表的头结点或红黑树的根节点进行加锁，将锁的级别控制在了更细粒度的级别，大大提高了并发量。</li>\n</ol>\n<h3 id=\"二、并发编程\"><a href=\"#二、并发编程\" class=\"headerlink\" title=\"二、并发编程\"></a>二、并发编程</h3><h4 id=\"1、volatile关键字\"><a href=\"#1、volatile关键字\" class=\"headerlink\" title=\"1、volatile关键字\"></a>1、volatile关键字</h4><ol>\n<li>volatile保证变量对所有线程的可见性，当volatile变量被修改时，新值对所有变量会立即更新。即多线程环境下使用volatile修饰的变量的值一定是最新的。</li>\n<li>禁止指令重排序</li>\n</ol>\n<h4 id=\"2、synchronized关键字\"><a href=\"#2、synchronized关键字\" class=\"headerlink\" title=\"2、synchronized关键字\"></a>2、synchronized关键字</h4><p>主要是用于解决多个线程之间访问资源的同步性，可以保证被其修饰的方法或代码块在任意时刻只能有一个线程执行。（悲观锁的思想）</p>\n<p>修饰实例方法：给当前对象实例加锁，进入同步代码块之前需要获取当前对象实例的锁</p>\n<p>修饰静态方法：给当前的类加锁，会作用于当前类的所有对象实例。</p>\n<p>修饰代码块：既可以锁定对象实例，也可以锁定类，以括号中的代码为准</p>\n<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>\n</ul>\n<p><strong>底层实现：</strong>主要通过两个指令实现，monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块的结束位置。在执行monitorenter指令时，线程尝试获取锁也就是获取对象监视器monitor的持有权，对象监视器是由c++实现的，每个对象中都内置了一个对象监视器对象。如果锁的计数器为0，则表示可以被获取，获取后将锁计数器设为1，业务执行完毕后通过monitorexit指令释放锁，将锁的计数器设为0，然后其他线程才可以尝试获取锁。如果获取锁失败，当前线程需要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<h4 id=\"3、乐观锁-与-悲观锁\"><a href=\"#3、乐观锁-与-悲观锁\" class=\"headerlink\" title=\"3、乐观锁 与 悲观锁\"></a>3、乐观锁 与 悲观锁</h4><ol>\n<li><strong>悲观锁：</strong>总是假设最坏的情况，认为资源每次被访问的时候都会出问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，共享资源每次只给一个线程使用，其他线程都会阻塞。高并发场景下会增加系统开销，因为线程阻塞会导致系统的上下文切换。还有可能造成死锁的问题。</li>\n<li><strong>乐观锁：</strong>乐观锁总是假设最好情况，认为共享资源每次被访问都不会出现问题，线程无需等待，只是在提交修改的时候去验证对应的数据是否被其他线程修改了（<strong>版本号或者CAS算法</strong>）</li>\n<li><strong>使用场景</strong>：悲观锁适用于：写操作比较多的场景 乐观锁适用于：读操作较多的场景</li>\n<li><strong>乐观锁的实现：</strong><ol>\n<li><strong>版本号机制：</strong>在数据表中加上一个数据版本号的字段，表示数据被修改的次数，要更新数据前读取该版本，更新操作完成，提交更新时再次读取版本号的值，与之前的值相等才更新。</li>\n<li><strong>CAS算法：</strong>Compare And Swap（比较与交换）思想：使用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。乐观锁产生的问题<ol>\n<li>ABA问题：初次读取值为A，要更新时再检查依然是A，但是这个过程中被改为了B，又重新改为了A。</li>\n<li>CAS自旋操作：就是执行不成功就一直循环执行直到成功为止，如果长时间循环，会对CPU带来较大的开销</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4、线程死锁\"><a href=\"#4、线程死锁\" class=\"headerlink\" title=\"4、线程死锁\"></a>4、线程死锁</h4><p>多个线程同时被阻塞，产生死锁的四个必要条件：</p>\n<ol>\n<li>互斥条件，该资源在任意一个时刻只能由一个线程占用</li>\n<li>请求与保持：一个线程因为请求资源被阻塞时，不会去是释放已经占用的资源</li>\n<li>不剥夺条件：在线程未主动释放资源之前，不能被其他线程强行剥夺，只能使用完毕自行释放</li>\n<li>循环等待：若干线程在等待资源时形成了首尾相接的情况</li>\n</ol>\n<p>预防死锁：</p>\n<ol>\n<li>破坏互斥条件：一次性申请所有资源</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请资源时如果被阻塞，就主动释放它所占用的资源</li>\n<li>按序申请资源，破坏循环等待条件</li>\n</ol>\n<p>避免死锁：</p>\n<p>借助算法，如银行家算法等对资源分配进行计算评估，使其进入安全状态。</p>\n<p>还有哪些关键字</p>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231225103712047.png\" alt=\"image-20231225103712047\"></p>\n<h4 id=\"5、说说线程的生命周期和状态\"><a href=\"#5、说说线程的生命周期和状态\" class=\"headerlink\" title=\"5、说说线程的生命周期和状态?\"></a>5、说说线程的生命周期和状态?</h4><p>New:初始状态，线程被创建之后但没有被调用Start()</p>\n<p>RUNNABLE:运行状态，线程被调用了Start()等待运行的状态。</p>\n<p>​\t在操作系统层面是有：READY和Running状态的区分，但是在JVM层面只能看到RUNNABLE状态</p>\n<p>BLOCK:阻塞状态，需要等待锁释放</p>\n<p>WAITING:等待状态，需要其他线程通知或中断</p>\n<p>TIME_WAITING:超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待</p>\n<p>TERMINATED：终止状态，表示该线程运行完毕</p>\n<h4 id=\"6、线程的上下文切换\"><a href=\"#6、线程的上下文切换\" class=\"headerlink\" title=\"6、线程的上下文切换\"></a>6、线程的上下文切换</h4><p>每个线程在执行过程中，会有自己的运行条件和状态(也称为上下文)，当出现如下情况时，线程会从占用CPU的状态退出。主动让出CPU，比如调用了sleep、wait等，时间片用完、或者请求 IO，线程被阻塞。然后就会发生线程切换，需要保存当前线程的上下文，用于线程下次占用CPU的时候恢复线程。并加载下一个将要占用CPU的线程的上下文。如果切换频繁就会造成系统的整体效率低下</p>\n<h4 id=\"7、线程池的核心参数：\"><a href=\"#7、线程池的核心参数：\" class=\"headerlink\" title=\"7、线程池的核心参数：\"></a>7、线程池的核心参数：</h4><ol>\n<li>corePoolSize：核心线程大小，线程池一直运行，核心线程就不会停止</li>\n<li>maximumPoolSize：线程池最大线程数量，</li>\n<li>keepAliveTime：非核心线程的心跳时间，在该时间内没有运行任务，就会消亡</li>\n<li>workQueue：新任务来的时候判断当前运行的线程数量是否达到核心线程数，如果达到，任务就会被存放到阻塞队列。</li>\n<li>unit：keepAliveTime的时间单位</li>\n<li>ThreadFactory：线程工厂，创建新线程会用到</li>\n<li>defaultHandler：饱和策略。</li>\n</ol>\n<h4 id=\"8、Java-实现并发的几种方法\"><a href=\"#8、Java-实现并发的几种方法\" class=\"headerlink\" title=\"8、Java 实现并发的几种方法\"></a>8、Java 实现并发的几种方法</h4><ol>\n<li>synchronized关键字</li>\n<li>Volatile关键字</li>\n<li>实现Runnable接口创建线程</li>\n<li>继承Thread类创建线程</li>\n<li>线程池</li>\n<li>stream流也可以</li>\n</ol>\n<h3 id=\"三、JVM\"><a href=\"#三、JVM\" class=\"headerlink\" title=\"三、JVM\"></a>三、JVM</h3><h4 id=\"1、JVM内存分区模型\"><a href=\"#1、JVM内存分区模型\" class=\"headerlink\" title=\"1、JVM内存分区模型\"></a>1、JVM内存分区模型</h4><p>主要分为以下几个区域：</p>\n<ol>\n<li><strong>程序计数器</strong>：每个线程都有自己的程序计数器，用于指示当前线程执行的字节码指令的行号，分支、循环、跳转、异常处理等基础功能都依赖这个指示器完成。每个线程都有一个独立的程序计数器，确保线程切换后能恢复到正确的执行位置。</li>\n<li><strong>虚拟机栈</strong>：也称为Java方法栈，用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息。每个线程在执行一个方法时，都会为该方法分配一个栈桢，并将其压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈。</li>\n<li><strong>本地方法栈</strong>：与虚拟机栈类似，用于存储本地方法的执行信息</li>\n<li><strong>堆</strong>：用于存储对象实例，是JVM中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的对象实例都有一个标记用于指示对象是否存活。垃圾回收器会周期性地回收那些没有被标记为存活的对象。</li>\n<li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即编译器编译后的代码等数据</li>\n<li><strong>运行时常量池</strong>：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用的常量池。</li>\n</ol>\n<h4 id=\"2、JVM垃圾回收算法\"><a href=\"#2、JVM垃圾回收算法\" class=\"headerlink\" title=\"2、JVM垃圾回收算法\"></a>2、JVM垃圾回收算法</h4><p>常见的垃圾回收算法有以下几种类型：</p>\n<ol>\n<li><strong>标记——清除算法：</strong>分为标记和清除两个阶段。标记阶段遍历所有活动对象并打上标记，清除阶段将未被标记的对象删除。优点是不需要连续的内存空间，缺点是清除后可能会产生内存碎片</li>\n<li><strong>复制算法：</strong>将可用内存分为两块，只使用其中一块，当一块满了，将存活对象复制到另一块未被使用的空间，然后清除使用的那块。优点是：简单高效，不会产生内存碎片。缺点是可用内存缩小为原来的一半。不适合老年代：存活对象数量比较大，复制性能很差。</li>\n<li><strong>标记——整理算法：</strong>与标记——清除类似，在标记阶段与其相似，但是在清除阶段将存活对象整理到内存的一端，然后清除端边界外的所有对象。优点是不会产生内存碎片，缺点是比较慢。</li>\n<li><strong>分代收集算法：</strong>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活的时间将内存分为几个区域，每个区域采用不同的回收策略。新生代、老年代分别采取不同的回收算法。<ol>\n<li>新生代：分为一个Eden区和两个Survivor 区，当Eden区没有空间时，虚拟机将发起一次Minor GC（只对新生代进行垃圾收集），执行完后，如果对象能够存在Eden区的话，就会直接在Eden分配内存。对象每在Survior区熬过一次，年龄标志就增长1，增长到一定程度就会晋升到老年代中，这个值默认是15</li>\n<li>大对象和长期存活的对象将会进入老年代，Old GC，只对老年代进行垃圾收集</li>\n<li>Mixed GC：混合收集</li>\n<li>Full GC，收集整个Java堆和方法区</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3、双亲委派模式\"><a href=\"#3、双亲委派模式\" class=\"headerlink\" title=\"3、双亲委派模式\"></a>3、双亲委派模式</h4><p>是Java类加载器在加载类时所采用的的一种设计模式。这种模式的核心思想是：当一个类加载器收到类加载请求时，首先不会自己尝试加载，而是将请求委派给它的父类加载器。依次递归，指导最顶层的启动类加载器；如果父类加载器无法加载该类，子类才尝试自己加载。</p>\n<p>主要作用：</p>\n<ol>\n<li><strong>避免类的重复加载</strong>：通过委派给父类加载器，同一个类不会被多个类加载器重复加载。有助于节省内存资源</li>\n<li><strong>保护Java核心类库</strong>：由于双亲委派制的存在，用户自定义的类加载器无法直接加载Java核心类库，java.lang.String等。能够确保Java核心类库的安全性。例如当我们自定义了一个java.lang包，并且定义了一个类String，一旦运行代码，需要加载这个类的时候，就会向上一层层的委派到顶层的<strong>启动类加载器</strong>，顶层的引导类加载器会加载Java核心类库中的java.lang.String，该类中没有main方法，因此程序提示在<strong>java.lang.String类中找不到main方法</strong><ol>\n<li><img src=\"https://ask.qcloudimg.com/http-save/yehe-2219188/k9iysve4gq.png\" alt=\"img\"></li>\n</ol>\n</li>\n<li><strong>维护类加载器的层次结构</strong>：双亲委派模式使得各级类加载器可以按照⼀定的层次结构来组织和管理。这有助于 降低类加载器的复杂性，简化类加载过程。</li>\n</ol>\n<h4 id=\"4、JVM-的垃圾回收机制\"><a href=\"#4、JVM-的垃圾回收机制\" class=\"headerlink\" title=\"4、JVM 的垃圾回收机制\"></a>4、JVM 的垃圾回收机制</h4><p>在Java中，程序员不需要显示的区释放一个对象的内存，而是由虚拟机自行执行。想要知道JVM的垃圾回收机制，首先我们得知道JVM是如何给一个对象分配内存的。</p>\n<ol>\n<li>大多数情况下，对象会在新生代中的Eden区进行分配内存，当Eden区没有足够空间时，会进行一次Minor GC。此时会将Eden区域的内容转移到Survivor中去，如果该空间不足，会通过分配担保机制将新生代的对象提前转移到老年代中。</li>\n<li>大对象也会直接进入老年代中，如字符串、数组等</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象分配一个Age计数器，初始在Eden区为0，经过一次Minor GC还存活，并且可以被Survivor区域所容纳，就会移动到Survivor区，Age计数器加一。每存活过一次Minor GC，Age计数器就会 + 1。到达15时，会转移到老年代中。</li>\n</ol>\n<ul>\n<li>如何判断是否需要进行回收：<ol>\n<li>进行可达性分析：通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</li>\n<li>然后通过一些垃圾回收算法进行垃圾回收。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5、新生代和老生代怎么区分的\"><a href=\"#5、新生代和老生代怎么区分的\" class=\"headerlink\" title=\"5、新生代和老生代怎么区分的\"></a>5、新生代和老生代怎么区分的</h4><h3 id=\"四、计算机网络\"><a href=\"#四、计算机网络\" class=\"headerlink\" title=\"四、计算机网络\"></a>四、计算机网络</h3><h4 id=\"TCP连接的三次握手\"><a href=\"#TCP连接的三次握手\" class=\"headerlink\" title=\"TCP连接的三次握手\"></a>TCP连接的三次握手</h4><p>最开始，客户端和服务端都处于<code>Close</code>状态，先是服务端主动监听某个端口，进入<code>Listen</code>状态。</p>\n<ol>\n<li>第一次握手，由客户端向服务端发送建立连接的请求，向服务端发送一个同步报文，同时初始化一个随机数作为<strong>客户端的初始序列号seq&#x3D;x</strong>，并且进入SYN_SENT状态，等待服务器的确认。服务端接到请求之后，可以确认自己的接受能力和客户端的发送能力正常。</li>\n<li>第二次握手，服务端受到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文，确认号ack&#x3D;x+1，同时初始化一个随机数作为<strong>服务端的初始序列号seq&#x3D;y</strong>，此时服务器进入SYN_RECV状态。客户端收到这次报文后，能够确认自己的收、发能力，以及服务端的收、发能力都正常。</li>\n<li>客户端收到服务端的确认之后，向服务端发送一个确认报文，确认号ack&#x3D;y+1，序列号seq &#x3D; x+1，服务端接收到这次报文之后能够确认自己的发送能力和客户端的接收能力都正常，完成三次握手，第三次握手还可以携带数据。</li>\n</ol>\n<h4 id=\"为什么是三次握手？\"><a href=\"#为什么是三次握手？\" class=\"headerlink\" title=\"为什么是三次握手？\"></a>为什么是三次握手？</h4><ol>\n<li>三次握手可以阻止重复历史连接的初始化</li>\n<li>三次握手才可以同步双方的初始序列号</li>\n<li>三次握手才可以保证双方均具有接收和发送的能力</li>\n</ol>\n<h4 id=\"TCP连接的四次挥手\"><a href=\"#TCP连接的四次挥手\" class=\"headerlink\" title=\"TCP连接的四次挥手\"></a>TCP连接的四次挥手</h4><p>第一次挥手，客户端向服务端发送连接释放报文FIN，主动关闭连接，同时等待服务端的确认，序列号&#x3D;客户端上次发送报文的最后一个字节的序号+1，确认号是服务端上次发送的报文的最后一个字节的序号+1</p>\n<p>第二次挥手：服务端接收到连接释放的报文后，立即发出确认报文，序列号等于刚才客户端的确认号，确认号等于刚才客户端的序列号+1。此时TCP处于半关闭状态，服务端还可以继续向客户端发送没有发完的数据，发送完毕后。</p>\n<p>第三次挥手，服务端向客户端发送连接释放报文FIN，主动关闭连接，同时等待客户端的确认。序列号&#x3D;服务端上次发送报文的最后一个字节的序号+1，与第二次挥手相同，因为这段时间客户端没有发送数据</p>\n<p>第四次挥手：客户端收到服务端的释放连接报文后，立即发送确认报文，序列号等于&#x3D;上面的确认号+1，确认号&#x3D;上面的序列号+1，服务端进入Close状态。然后客户端进入TIME_WAIT状态，等待2*MSL（最长报文寿命），之后才会进入Close状态。</p>\n<h5 id=\"为什么需要等待2-MSL：\"><a href=\"#为什么需要等待2-MSL：\" class=\"headerlink\" title=\"为什么需要等待2*MSL：\"></a>为什么需要等待2*MSL：</h5><p>​\t确保第四次握手，客户端的确认报文能够到达服务端，从而使服务端正常关闭连接。如果没有正常到达服务端，服务端会超时重传FIN，此时如果客户端已经断开连接，那么就无法响应服务端的请求，服务端无法正常收到确认报文，无法正常关闭连接。2*MSL&#x3D;客户端确认报文1MSL+服务端重传FIN报文1MSL，这样能够确保服务端能够正常关闭。</p>\n<h3 id=\"职业规划\"><a href=\"#职业规划\" class=\"headerlink\" title=\"职业规划\"></a>职业规划</h3><ul>\n<li>能在1-2年完全胜任岗位职责，有优秀的产出</li>\n<li>2-3年成为岗位熟手，自身优秀的同时能带教新人</li>\n<li>3-5年成为业务骨干或一线经理，能带领小团队协作完成任务</li>\n</ul>\n",
            "tags": [
                "Javase"
            ]
        },
        {
            "id": "https://ooooddddd.github.io/2024/01/03/%E6%A9%99-API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/",
            "url": "https://ooooddddd.github.io/2024/01/03/%E6%A9%99-API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/",
            "title": "橙-API开放平台相关问题",
            "date_published": "2024-01-03T11:58:05.000Z",
            "content_html": "<p>基于React + Spring Boot + Dubbo + Gateway的API接口开放调用平台。管理员可以接入并发布接口，可视化各接口调用情况；用户可以开通接口调用权限、浏览接口及在线调试，并通过客户端 SDK 轻松调用接口。</p>\n<p><strong>项目难点：</strong></p>\n<ul>\n<li><p>权限校验，切面注解。</p>\n<ol>\n<li><p>首先定义一个注解类，该注解允许在方法上定义两种权限规则：<code>anyRole</code> 表示任意角色通过，<code>mustRole</code> 表示必须有特定角色才能通过。</p>\n<ul>\n<li><pre><code class=\"java\">/**\n * 权限校验\n * @author zc\n   */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n   public @interface AuthCheck &#123;\n\n   /**\n\n    * 有任何一个角色\n      *\n    * @return\n      */\n      String[] anyRole() default &quot;&quot;;\n\n   /**\n\n    * 必须有某个角色\n      *\n    * @return\n      */\n      String mustRole() default &quot;&quot;;\n\n&#125;\n<pre class=\"language-none\"><code class=\"language-none\">\n2. 然后定义一个拦截器进行权限校验\n\n   &#96;&#96;&#96;java\n   &#x2F;**\n    * 权限校验 AOP\n    *\n    * @author zc\n    *&#x2F;\n   @Aspect\n   @Component\n   public class AuthInterceptor &#123;\n   \n       @Resource\n       private UserService userService;\n   \n       &#x2F;**\n        * 执行拦截\n        *\n        * @param joinPoint\n        * @param authCheck\n        * @return\n        *&#x2F;\n       @Around(&quot;@annotation(authCheck)&quot;)\n       public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable &#123;\n           List&lt;String&gt; anyRole &#x3D; Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());\n           String mustRole &#x3D; authCheck.mustRole();\n           RequestAttributes requestAttributes &#x3D; RequestContextHolder.currentRequestAttributes();\n           HttpServletRequest request &#x3D; ((ServletRequestAttributes) requestAttributes).getRequest();\n           &#x2F;&#x2F; 当前登录用户\n           User user &#x3D; userService.getLoginUser(request);\n           &#x2F;&#x2F; 拥有任意权限即通过\n           if (CollectionUtils.isNotEmpty(anyRole)) &#123;\n               String userRole &#x3D; user.getUserRole();\n               if (!anyRole.contains(userRole)) &#123;\n                   throw new BusinessException(ErrorCode.NO_AUTH_ERROR);\n               &#125;\n           &#125;\n           &#x2F;&#x2F; 必须有所有权限才通过\n           if (StringUtils.isNotBlank(mustRole)) &#123;\n               String userRole &#x3D; user.getUserRole();\n               if (!mustRole.equals(userRole)) &#123;\n                   throw new BusinessException(ErrorCode.NO_AUTH_ERROR);\n               &#125;\n           &#125;\n           &#x2F;&#x2F; 通过权限校验，放行\n           return joinPoint.proceed();\n       &#125;\n   &#125;</code></pre>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>最后在需要进行权限校验的方法上添加<code>@AuthCheck</code>注解即可</p>\n<ul>\n<li><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20240102135217501.png\" alt=\"image-20240102135217501\"></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>网关设计</p>\n</li>\n</ul>\n<h4 id=\"1、为什么要做这个项目：\"><a href=\"#1、为什么要做这个项目：\" class=\"headerlink\" title=\"1、为什么要做这个项目：\"></a>1、为什么要做这个项目：</h4><p>尽可能地帮助和服务更多的用户和开发者，让他们可以方便快捷地获取他们想要的信息和功能。接口开放平台可以帮助开发者快速接入一些常用的服务，从而提高他们的开发效率，比如天气服务、随机头像、心灵鸡汤等，他们是一些应用或者小程序中常见的功能，所以提供这些接口可以帮助开发者更加方便地实现这些功能。这些接口也可以让用户在使用应用时获得更加全面的功能和服务，从而提高用户体验。所以我认为接口开放平台是一个有意义的项目，可以为用户和开发者带来更多的便利和价值。</p>\n<p>表结构：用户表（user）、接口信息表（interfaceInfo）、用户接口表（userInterface，用于记录用户对接口是否有调用权限，是否有剩余调用次数等）、土味情话表（用于提供随机土味情话服务的接口需要的表）</p>\n<h4 id=\"2、项目架构设计\"><a href=\"#2、项目架构设计\" class=\"headerlink\" title=\"2、项目架构设计\"></a>2、项目架构设计</h4><p>采用了前后端分离的架构设计。前端使用Ant-design-pro框架快速开发，然后使用Nginx进行部署，通过Nginx反向代理将请求转发到后端Web项目，因为项目刚刚上线，用户量较少，暂时采用了单机部署的模式，未来可能采取<strong>水平扩容</strong>的方式，增加多台节点，通过nginx的<strong>负载均衡</strong>，将请求平均的分发到多个节点上，以支撑更高的并发量。我的web项目使用Spring Boot开发，并且连接到到了 Mysql数据库 和 Redis，数据库主要用来存储用户和接口的相关信息，通过Redis实现了分布式session，因为考虑到未来要是用分布式架构，可以避免使用tomcat保存session出现用户登录失效的问题。</p>\n<h5 id=\"反向代理与正向代理\"><a href=\"#反向代理与正向代理\" class=\"headerlink\" title=\"反向代理与正向代理\"></a>反向代理与正向代理</h5><p>反向代理：客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器 IP 地址。反向代理“代理”的是目标服务器。</p>\n<p>正向代理：顺着请求的方向进行的代理，即代理服务器它是由你配置为你服务，去请求目标服务器地址。类似于科学上网</p>\n<h5 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h5><p>常见的负载均衡算法：</p>\n<ol>\n<li>随机法，如果没有配置权重的话，所有服务器被访问到的概率是相等的。权重越高，被访问到的概率也越高。适合服务器性能接近的集群，其中每个服务器承载相同的负载，缺点：部分机器在一段时间之内无法被访问到。</li>\n<li>轮询法：挨个服务器进行访问，当然，也可以设置权重。</li>\n<li>一致性Hash法：相同参数的请求总是发送到同一台服务器进行处理，比如同个IP的请求</li>\n<li>最小连接法：遍历服务器节点列表，选取活动连接数（可以理解为正在处理的请求数）最小的一台服务器来响应当前的请求。</li>\n<li>两次随机法：两次随机法在随机法的基础上多了一次随机，多选出一台服务器，然后根据两台服务器的负载情况，从中选择一台最合适的</li>\n</ol>\n<h5 id=\"水平扩容\"><a href=\"#水平扩容\" class=\"headerlink\" title=\"水平扩容\"></a>水平扩容</h5><p>垂直扩容：增加自身的容量。</p>\n<p>水平扩容：增加节点的方式来增加整个系统的容量。垂直扩容比较方便，但是会受制于机器的内存、性能等。所以到了一定阶段肯定要进行水平扩容。</p>\n<h4 id=\"3、技术选型及原因\"><a href=\"#3、技术选型及原因\" class=\"headerlink\" title=\"3、技术选型及原因\"></a>3、技术选型及原因</h4><p>使用SpringBoot是因为通过<strong>自动装配</strong>能够提高项目的开发效率，能够很好地整合Spring的相关服务。使用Mysql的原因是考虑到未来打算上用户充值交易功能，限制调用次数等场景需要使用事务来保证数据的<strong>完整性和一致性</strong>。使用Redis是因为可以用来实现分布式session、锁、缓存等功能。因为Redis是一个单独的中间件，不同客户端可以向同一个Redis或者集群中存放session&#x2F;加锁，能够保证资源在分布式服务下都可见。由于Redis是单线程的，同时也支持Lua脚本，可以保证并发安全的问题，也能够轻松实现分布式锁的功能。</p>\n<h5 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h5><p><strong>什么是自动装配：</strong>在没有SpringBoot的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，在SpringBoot中，我们直接引入一个 starter 即可。比如想要使用redis的话，直接在项目中引入对应的starter，然后在application.yml中配置即可。</p>\n<p><strong>如何实现自动装配与按需加载的：</strong>核心注解：SpringBootApplication注解，是@EnableAutoConfiguration、（启用SpringBoot的自动装配机制）@Configuration（允许上下文中注册额外的bean或者导入其他配置类）、@ComponentScan（扫描被@Compent、@Service、@Controller注解修饰的bean），注解默认会扫描启动类所在的包下的所有类，也可以自定义不扫描某些bean。</p>\n<p>自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类实现的，该类实现<code>ImportSelector</code>接口，同时实现接口中的<code>selectImports</code>方法，该方法<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。主要是通过读取<code>META-INF/spring.factories</code>来获取需要自动装配的类的。同时根据<code>@ConditionalOnXXX</code>注解来实现按需加载</p>\n<p>项目中的SDK利用上述功能开发成了一个Starter，首先引入Spring Boot 相关依赖，然后创建一个类</p>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231221102811685.png\" alt=\"image-20231221102811685\"></p>\n<p>最后在resources&#x2F;META-INF目录下创建一个spring.factories文件，引入该类</p>\n<pre class=\"language-none\"><code class=\"language-none\">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.zc.orangeapiclientsdk.OrangeApiClientConfig</code></pre>\n\n<p>此时，该类就被做成了一个Starter，可以给其他开发者调用。</p>\n<h5 id=\"共享session\"><a href=\"#共享session\" class=\"headerlink\" title=\"共享session\"></a>共享session</h5><p>在分布式系统中，存在多台服务器，如果用户登陆信息存储在服务器1中，第二次访问时用户被分配到了服务器2，此时就需要重新登陆。因此引入Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>\n<h4 id=\"4、开发流程\"><a href=\"#4、开发流程\" class=\"headerlink\" title=\"4、开发流程\"></a>4、开发流程</h4><p>首选参考了一些已有的产品，根据这些产品，总结出比较好的功能点，再结合自己想要实现的一些特色功能，做了一个项目的整体设计，然后再进行技术选型。</p>\n<h4 id=\"5、项目核心：网关\"><a href=\"#5、项目核心：网关\" class=\"headerlink\" title=\"5、项目核心：网关\"></a>5、项目核心：网关</h4><p>本平台的关键点就在于提供接口服务，要保证接口的高可用性和稳定性，所有的接口服务项目独立进行部署，隐藏其真实的接口地址及调用，调用接口服务的请求都必须经过网关进行统一鉴权、流量控制（路由转发）、流量染色、负载均衡，接口保护、统一日志等，之后再将请求转发到真实的接口地址，防止接口地址被恶意调用，盗刷等。</p>\n<p>在本项目中，使用API网关做了什么：</p>\n<p>1、统一鉴权：应用API签名认证算法校验用户请求的合法性。</p>\n<p>2、公共业务逻辑：对每个接口的调用进行集中的统计。</p>\n<p>3、路由转发：前端发送请求到API网关，通过网关转发到实际的接口地址</p>\n<p>4、流量染色：给经过网关的请求加上特定的请求头参数，便于让API服务确定来源及合法性。</p>\n<h4 id=\"6、API签名认证算法\"><a href=\"#6、API签名认证算法\" class=\"headerlink\" title=\"6、API签名认证算法\"></a>6、API签名认证算法</h4><p>该算法是用于验证API请求的合法行和完整性的安全机制。具体实现：</p>\n<p>1、生成密钥对，给每个用户生成唯一的密钥对(ak,sk)，并保存到数据库中，仅用户本人可查看自己的密钥对。</p>\n<p>2、请求方生成签名：请求方（客户端）使用sk对请求参数和数据进行签名，签名内容包括请求参数、时间戳、随机数等，签名加密算法此处选择MD5</p>\n<p>3、请求方发送请求：请求方将请求参数、签名、用户标识一起发送给API提供者，通常会把签名信息放到请求头参数中传递，注意这里千万不能传递sk。</p>\n<p>4、API提供者验证签名：在API网关中，通过请求头获取到用户标识，根据该标识去数据库查询到该用户对应的ak，sk，并使用相同的签名算法生成签名，和请求头中的签名进行对比，如果一致，则API提供者可以信任请求方，然后可以进行后续的操作。</p>\n<h4 id=\"7、为什么使用Dubbo-RPC\"><a href=\"#7、为什么使用Dubbo-RPC\" class=\"headerlink\" title=\"7、为什么使用Dubbo RPC\"></a>7、为什么使用Dubbo RPC</h4><p>RPC（远程过程调用）是一种用于实现分布式系统通信的协议和技术。它允许一个计算机从程序调用另一个地址的函数或方法，就像本地调用一样。Dubbo是基于Java的高性能、轻量级的开源RPC框架，便于开发者轻松实现分布式系统和微服务架构。简单来说就是性能高、协议多、功能强、生态好、易扩展</p>\n<h4 id=\"8、如何使用的Dubbo-RPC\"><a href=\"#8、如何使用的Dubbo-RPC\" class=\"headerlink\" title=\"8、如何使用的Dubbo RPC\"></a>8、如何使用的Dubbo RPC</h4><p>在正式运用Dubbo到项目中之前，先阅读了Dubbo的官方文档，利用快速启动跑通了基础的RPC调用的Demo，明确了注册中心，Maven包依赖和各种版本号。先在本地启动Nacos注册中心，然后在服务提供者和服务调用者项目引入Dubbo依赖（最好是引入相同的依赖和配置），编写nacos的连接配置，并且需要在启动类通过@EnableDubbo注解开启Dubbo支持</p>\n<p>编写服务提供者类和服务调用者客户端类，分别加上@DubboService和DubboReference注解，优先启动服务提供者项目，在Nacos控制台观察到注册信息之后，再启动服务调用者项目。</p>\n<h4 id=\"9、\"><a href=\"#9、\" class=\"headerlink\" title=\"9、\"></a>9、</h4>",
            "tags": [
                "API开放平台"
            ]
        },
        {
            "id": "https://ooooddddd.github.io/2024/01/03/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "https://ooooddddd.github.io/2024/01/03/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "MySQL面试题",
            "date_published": "2024-01-03T11:46:41.000Z",
            "content_html": "<h1 id=\"Mysql相关面经\"><a href=\"#Mysql相关面经\" class=\"headerlink\" title=\"Mysql相关面经\"></a>Mysql相关面经</h1><h3 id=\"执行一条-SQL-查询语句，期间发生了什么？\"><a href=\"#执行一条-SQL-查询语句，期间发生了什么？\" class=\"headerlink\" title=\"执行一条 SQL 查询语句，期间发生了什么？\"></a>执行一条 SQL 查询语句，期间发生了什么？</h3><ol>\n<li>连接器：客户端通过TCP请求发送连接请求到Mysql连接器，连接器会对该请求进行权限验证和连接资源分配</li>\n<li>查询缓存，命中缓存则直接返回数据，否则继续向下执行</li>\n<li>解析SQL，通过解析器对SQL语句进行词法、语法分析，检查数据表和数据列是否存在，别名是否存在歧义等</li>\n<li>优化，是否使用索引，生成执行计划</li>\n<li>交给执行器，将数据保存到结果集中，同时逐步将数据缓存到查询缓存当中，最后将结果集返回给客户端。</li>\n</ol>\n<h3 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h3><h4 id=\"用过哪些索引\"><a href=\"#用过哪些索引\" class=\"headerlink\" title=\"用过哪些索引\"></a>用过哪些索引</h4><h5 id=\"索引的作用\"><a href=\"#索引的作用\" class=\"headerlink\" title=\"索引的作用\"></a><strong>索引的作用</strong></h5><p>相当于书的目录，是一种可以用于快速查询和检索数据的数据结构，可以看成是一种排序好的数据结构。</p>\n<h5 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a><strong>优缺点</strong>：</h5><p>优点：可以加快数据的检索速度，主要是大大减少检索的数据量。通过唯一性索引，可以保证数据库表中的每一行数据的唯一性。</p>\n<p>缺点：从时间层面讲：创建和维护索引需要耗费时间，并且对表中的数据进行增删改的时候，如果存在索引，那么索引也需要动态修改，一定程度上会减低SQL的执行效率。空间上：索引也需要文件进行存储，耗费一定的空间。</p>\n<h5 id=\"索引的数据结构类型\"><a href=\"#索引的数据结构类型\" class=\"headerlink\" title=\"索引的数据结构类型\"></a>索引的数据结构类型</h5><p><strong>哈希索引：</strong>精确匹配索引所有列的查询数据，对于每一行数据，存储引擎针对所有索引列计算一个哈希码。为什么不使用这个，主要是因为hash索引不支持顺序和范围查询，只适合等值查询。</p>\n<p><strong>B-Tree和B+Tree索引的区别</strong></p>\n<ol>\n<li>B树的所有节点都会存放key和data，而B+数只有叶子节点存放key和data，其他内节点只存放key。</li>\n<li>B树的叶子节点都是独立的，而B+树的叶子结点有一条指向相邻叶子结点的引用，更加方便扫库</li>\n<li>B树进行范围查询，需要对树进行中序遍历，直到找到查找的上限，而B+树的范围查询，只需要遍历叶子结点组成的链表即可。</li>\n</ol>\n<p>综上所述，B+具备更稳定的查询效率，更低的IO次数和更适合范围查询等优势而广泛应用。</p>\n<p><strong>主键索引</strong>，一张表中只能有一个主键，并且主键不能为null，不能重复，在mysql的InnoDB表中，如果没有显示指定表的主键时，InnoDB会自动先检查表中是否有唯一索引且不允许存在null的字段，如果有，则选择该字段作为主键索引，否则会自动创建一个6Byte的自增主键</p>\n<p><strong>二级索引</strong>：普通索引，前缀索引，全文索引</p>\n<h4 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h4><p>使用多个字段同时建立一个索引，叫做联合索引，在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序进行使用，否则可能无法命中。</p>\n<h5 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h5><p>在进行查询时</p>\n<ol>\n<li>遵循最左匹配原则</li>\n<li>同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li>\n<li>最左缀匹配原则的最重要的就是 第一个字段</li>\n<li>不推荐 select *<ol>\n<li>增加查询分析器解析成本。</li>\n<li>增减字段容易与 resultMap 配置不一致</li>\n<li>无用字段增加网络 消耗，尤其是 text 类型的字段。</li>\n<li>我们使用 B&#x3D;1 会走索引 但是 与直接查询索引字段不同 使用<code>SELECT*</code>,获取了不需要的数据，则首先通过辅助索引过滤数据，然后再通过聚集索引获取所有的列，这就多了一次 b+树查询，速度必然会慢很多，减少使用 select * 就是降低回表带来的损耗。</li>\n</ol>\n</li>\n</ol>\n<p>假如我们建立一个（a，b，c）的索引面，a，b，c在查询时的顺序可以任意调整</p>\n<p>例如查询(a,b)会走索引，（a，c）（c，a）也会走索引</p>\n<p>但是 (b,c),(c,b)之类的就不会走索引。</p>\n<p><strong>总结</strong></p>\n<ul>\n<li><p>select * 可能会走索引，不一定会造成索引失效，造成索引失效的大概率原因是where条件范围太广</p>\n</li>\n<li><p>**范围查询(&gt;、&lt;、between、like)**，范围查找有概率索引失效但是在特定的情况下会生效 范围小就会使用 也可以理解为 返回结果集小就会使用索引</p>\n</li>\n<li><p>创建了组合索引，但查询条件未遵循最左匹配原则;</p>\n</li>\n<li><p>在索引列上进行计算、函数、类型转换等操作;</p>\n</li>\n</ul>\n<p>建立索引语句</p>\n<p><code>DROP TABLE IF EXISTS student;</code><br><code>CREATE TABLE student (</code><br> <code>id int(11) NOT NULL AUTO_INCREMENT,</code><br> <code>sname varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</code><br> <code>s_code int(100) NULL DEFAULT NULL,</code><br> <code>address varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</code><br> <code>height double NULL DEFAULT NULL,</code><br> <code>classid int(11) NULL DEFAULT NULL,</code><br> <code>create_time datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0),</code><br> <code>PRIMARY KEY (id) USING BTREE,</code><br> <code>INDEX 普通索引(height) USING BTREE,</code><br> <code>INDEX 联合索引(sname, s_code, address) USING BTREE</code><br><code>) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</code></p>\n<h3 id=\"二、事务\"><a href=\"#二、事务\" class=\"headerlink\" title=\"二、事务\"></a>二、事务</h3><h4 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h4><ol>\n<li>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，在事务执行过程中发生错误，会被回滚到事物开始前的状态</li>\n<li>一致性：事务执行的结果必须是使数据库从一个一致性状态变化到另一个一致性状。</li>\n<li>隔离性：一个事务的执行不能被其他事务所干扰。</li>\n<li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<ul>\n<li>持久性是通过 redo log （重做日志）来保证的；</li>\n<li>原子性是通过 undo log（回滚日志） 来保证的；</li>\n<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>\n<li>一致性则是通过持久性+原子性+隔离性来保证；</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h4><ul>\n<li>脏读：读取到其他事务未提交的数据</li>\n<li>不可重复读：前后读取的数据不一致</li>\n<li>幻读：前后读取的记录数不一致</li>\n</ul>\n<p>针对上面几种现象，SQL标准定义了四种隔离级别来规避这些现象</p>\n<ol>\n<li>读未提交：所有事务均可看到其他事务未提交的执行结果，会导致上面三种现象的发生，因此很少应用。</li>\n<li>读已提交：一个事务只能看到其他已经提交的事务所对数据做出的改变，这个级别杜绝了脏读现象，但避免不了不可重复读和幻读</li>\n<li>可重复读：这个是Mysql InnoDB的默认事务隔离级别，指的是一个事务执行过程中所看到的数据，一直跟这个事务启动时看到的数据是一致的。可以解决脏读和不可重复读现象，但仍然可能发生幻读。</li>\n<li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，后访问的事务必须等待前一个事务执行完成，才能继续执行。在这个级别，可能会导致大量的超时现象和锁的竞争。</li>\n</ol>\n<h4 id=\"如何避免幻读现象\"><a href=\"#如何避免幻读现象\" class=\"headerlink\" title=\"如何避免幻读现象\"></a>如何避免幻读现象</h4><p>针对快照读（普通的 select 语句）：通过<strong>（MVCC）多版本并发控制实现</strong>的，开始事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句可以通过这个 Read View在 undo log 版本中找到事物开始时的数据，就保证了整个事务的过程中每次查询的数据都是一致的。即使中途有其他事务插入了新纪录，也是查询不出来的，很好地避免了幻读问题的发生。</p>\n<p>针对当前读（比如 update、insert、delete，这些语句），通过<strong>记录锁+间隙锁</strong>的方式解决欢度，当执行select … for update 语句时候，会加上记录锁和间隙锁，如果有其他事务在这时插入一条记录，会被阻塞，无法插入成功，能够避免幻读</p>\n<h3 id=\"三、日志\"><a href=\"#三、日志\" class=\"headerlink\" title=\"三、日志\"></a>三、日志</h3><p>更新语句的流程中会涉及到的三种日志：</p>\n<ol>\n<li><p>undo log（回滚日志）：是InnoDB存储引擎层生成的日志，实现了事务的原子性，主要用于事务回滚和MVCC（多版本并发控制）</p>\n</li>\n<li><p>redo log（重做日志）：是InnoDB存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障的恢复</p>\n</li>\n<li><p>binlog（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制。</p>\n</li>\n</ol>\n<h5 id=\"1、undo-log（回滚日志）\"><a href=\"#1、undo-log（回滚日志）\" class=\"headerlink\" title=\"1、undo log（回滚日志）\"></a>1、undo log（回滚日志）</h5><p>每当对一条记录进行增删改操作时，需要把回滚时需要的信息记录到 undo log 里，比如：</p>\n<ul>\n<li>在<strong>插入</strong>一条记录时，需要记录主键 id ，回滚时根据 id 删除记录即可</li>\n<li>在<strong>删除</strong>一条记录时，需要将该记录中的所有内容都记录下来，回滚时再把由这些内容组成的记录插入到表中即可</li>\n<li>在<strong>更新</strong>一条记录时，也是需要记录整列的内容，然后才能在回滚时更新为旧数据即可</li>\n</ul>\n<h5 id=\"1-1、undo-log-的格式\"><a href=\"#1-1、undo-log-的格式\" class=\"headerlink\" title=\"1.1、undo log 的格式\"></a>1.1、undo log 的格式</h5><p>以更新操作为例，每一次更新操作产生的undo log都由一个 roll_pointer 指针和一个 trx_id事务id构成</p>\n<ul>\n<li>通过事务id可以知道该条记录是由哪个事务修改的。</li>\n<li>通过指针可以将这个 undo log 串成一个链表，称为版本链。</li>\n</ul>\n<h5 id=\"1-2、如何实现MVCC（多版本并发控制）\"><a href=\"#1-2、如何实现MVCC（多版本并发控制）\" class=\"headerlink\" title=\"1.2、如何实现MVCC（多版本并发控制）\"></a>1.2、如何实现MVCC（多版本并发控制）</h5><p>通过 Read View 里面的字段和undo log 记录中的 事务id（trx_id），roll_pointer指针进行对比，找到满足其条件的记录，从而控制并发事务访问同一条记录的行为。</p>\n<h5 id=\"1-3、缓冲池-Buffer-Pool\"><a href=\"#1-3、缓冲池-Buffer-Pool\" class=\"headerlink\" title=\"1.3、缓冲池(Buffer Pool)\"></a>1.3、缓冲池(Buffer Pool)</h5><p>mysql的数据都是存放在磁盘中的，如果我们要更新一条数据，需要将其从磁盘中读出来，在内存中进行修改之后，先缓存起来，并不会直接写回磁盘，会等待合适时机再写回。</p>\n<p>为了缓存这些数据，mysql设计了一个缓冲池(Buffer Pool)，来提高数据库的读写性能。</p>\n<ul>\n<li>当读取数据时，如果数据存在于缓冲池中，客户端会直接读取到缓冲池中的数据，否则再去磁盘读取。</li>\n<li>当修改数据时，如果数据存在于缓冲池中，那么直接修改缓冲池中的数据所在的页，然后将这个页设置为脏页（就是该页的内存数据与磁盘中的数据不一致），为了减少磁盘IO，不会立即将脏页写入磁盘，后续由后台的其他线程选择合适时机将脏页写入磁盘。</li>\n<li>缓冲池中处理缓存数据页和索引页，还会缓存Undo 页（存放Undo log的），插入缓存，自适应哈希缓存，锁信息等等。</li>\n</ul>\n<h4 id=\"2、redo-log（重做日志）\"><a href=\"#2、redo-log（重做日志）\" class=\"headerlink\" title=\"2、redo log（重做日志）\"></a>2、redo log（重做日志）</h4><p>redo log 是物理日志，主要是用于记录某个数据页做了什么样的修改的操作。在执行事务的过程中，产生的redo日志文件是顺序写入磁盘的，写入 redo log 的方式使用了追加操作， 使用的是顺序IO，如果没有这个日志，我们需要把缓冲池中的修改写入磁盘需要使用随机IO，性能低下，并且日志的空间占用很小，刷盘更快。之后如果数据库发生崩溃，可以根据redo log进行恢复，保证了事务四大特性中的持久性。</p>\n<p>redo log 也不是直接写入磁盘的，它也有自己的缓存——redo log buffer</p>\n<h5 id=\"redo-log-刷盘的时机\"><a href=\"#redo-log-刷盘的时机\" class=\"headerlink\" title=\"redo log 刷盘的时机\"></a>redo log 刷盘的时机</h5><ol>\n<li>Mysql正常关闭</li>\n<li>当redo log buffer 中的记录写入量大于 redo log buffer 内存空间的一半时</li>\n<li>InnoDB的后台线程每隔 1 秒，将redo log buffer 持久化到磁盘</li>\n<li>每次事务提交时，这个策略可以由innodb_flush_log_at_trx_commit 参数控制，默认是1，就是每次事务提交时，都会将 redo log buffer 持久化到磁盘中。</li>\n</ol>\n<h4 id=\"3、bin-log（归档日志）\"><a href=\"#3、bin-log（归档日志）\" class=\"headerlink\" title=\"3、bin log（归档日志）\"></a>3、bin log（归档日志）</h4><p>与redo log 类似，记录了所有数据库表结构变更和表数据修改的日志，不记录查询类的操作</p>\n<h4 id=\"4、redo-log-和-bin-log-的区别\"><a href=\"#4、redo-log-和-bin-log-的区别\" class=\"headerlink\" title=\"4、redo log 和 bin log 的区别\"></a>4、redo log 和 bin log 的区别</h4><ul>\n<li>适用对象不同，binlog是Mysql Server 层实现的日志，所有存储引擎都可以使用。redo log 是InnoDB 存储引擎实现的日志</li>\n<li>文件格式不同</li>\n<li>写入方式不同<ul>\n<li>binlog是追加写，写满一个文件，就开一个新的继续写，不会覆盖一起的日志，保存的是全量的日志</li>\n<li>redo log 是循环写，日志空间大小是固定的，全部写满就从头开始。</li>\n<li>因此，如果不小心将数据库数据删除了，应该考虑使用binlog进行恢复</li>\n</ul>\n</li>\n<li>用途不同，bin log主要用于备份恢复，主从复制，redo log用于掉电等故障的恢复</li>\n</ul>\n<h4 id=\"5、主从复制的实现\"><a href=\"#5、主从复制的实现\" class=\"headerlink\" title=\"5、主从复制的实现\"></a>5、主从复制的实现</h4><ol>\n<li>主库写入Bin log，MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，</li>\n<li>从库会创建一个专门的 I&#x2F;O 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 暂存日志里，再返回给主库“复制成功”的响应。</li>\n<li>从库会创建一个用于回放 binlog 的线程，去读 暂存日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>\n</ol>\n<p>完成主从复制之后，可以写数据只写主库，读数据只读从库，减少锁资源的竞争，也不会影响读请求的执行，默认是异步复制</p>\n<h4 id=\"6、bin-log-的刷盘时机\"><a href=\"#6、bin-log-的刷盘时机\" class=\"headerlink\" title=\"6、bin log 的刷盘时机\"></a>6、bin log 的刷盘时机</h4><p>用来控制刷盘频率的参数，默认sync_binlog &#x3D; 0也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>\n<h3 id=\"四、锁\"><a href=\"#四、锁\" class=\"headerlink\" title=\"四、锁\"></a>四、锁</h3><p>根据类型：可分为：共享锁（读锁），排它锁（写锁）</p>\n<p>根据加锁的范围，可以分为<strong>全局锁、表级锁、行级锁</strong></p>\n<h4 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h4><p>使用全局锁：</p>\n<pre class=\"language-sql\" data-language=\"sql\"><code class=\"language-sql\">flush <span class=\"token keyword\">tables</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">read</span> <span class=\"token keyword\">lock</span></code></pre>\n\n<p>执行之后，整个数据库都处于只读状态了，不管是对数据的增删改，或者是对表结构的更改操作都会被阻塞</p>\n<p>释放：</p>\n<pre class=\"language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span></code></pre>\n\n<h5 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h5><p>主要用于做<strong>全库逻辑备份</strong>，防止出现备份文件的数据与预期的不同。</p>\n<p>如果备份时间过长，可能会导致业务停滞</p>\n<h5 id=\"如何避免其影响业务\"><a href=\"#如何避免其影响业务\" class=\"headerlink\" title=\"如何避免其影响业务\"></a>如何避免其影响业务</h5><p>对于使用InnoDB存储引擎的可重复读隔离级别的情况，在备份数据库之前先开启事务，会创建Read View，然后整个事务执行期间都使用这个Read View去进行数据的更新操作等。</p>\n<h4 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h4><p>表锁，元数据锁，意向锁，AUTO-INC锁</p>\n<p>表锁：对整个表加锁，不仅会限制其他线程的读写，也会限制本线程的读写操作。尽量避免在InnoDB引擎的表中使用表级锁，因为表锁的颗粒度太大，会影响并发性能，可以使用颗粒度更细的行级锁。</p>\n<h4 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>\n<ol>\n<li>记录锁，仅仅把一条记录锁上</li>\n<li>间隙锁，锁定一个范围，但不包含记录本身</li>\n<li>1+2，锁定一个范围，并且锁定记录本身。</li>\n</ol>\n",
            "tags": [
                "MySQL"
            ]
        }
    ]
}