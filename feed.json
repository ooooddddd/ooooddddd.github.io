{
    "version": "https://jsonfeed.org/version/1",
    "title": "橙熟",
    "description": "我的笔记",
    "home_page_url": "https://ooooddddd.github.io",
    "items": [
        {
            "id": "https://ooooddddd.github.io/2023/10/16/%E6%9C%AC%E5%9C%B0ChatGPT/",
            "url": "https://ooooddddd.github.io/2023/10/16/%E6%9C%AC%E5%9C%B0ChatGPT/",
            "title": "本地ChatGPT",
            "date_published": "2023-10-16T02:31:51.000Z",
            "content_html": "<h1 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h1>\n<p>部署好之后不再依赖科学上网</p>\n<h1 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h1>\n<p>仍然需要你有正常的 openAI 账号，token 登录方式</p>\n<h1 id=\"前置要求\"><a class=\"markdownIt-Anchor\" href=\"#前置要求\">#</a> 前置要求</h1>\n<ol>\n<li>搭载了 Centos7 的本地虚拟机</li>\n<li>在虚拟机上安装了 Docker，网上很多安装教程，这里不再展开赘述</li>\n</ol>\n<h1 id=\"拉取镜像启动容器\"><a class=\"markdownIt-Anchor\" href=\"#拉取镜像启动容器\">#</a> 拉取镜像，启动容器</h1>\n<ul>\n<li>拉取 pengzhile/pandora 镜像 (如果拉取失败，使用科学上网重试)</li>\n</ul>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull pengzhile/pandora</code></pre>\n<ul>\n<li>启动容器</li>\n</ul>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PANDORA_CLOUD</span><span class=\"token operator\">=</span>cloud <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PANDORA_SERVER</span><span class=\"token operator\">=</span><span class=\"token number\">0.0</span>.0.0:9527 <span class=\"token parameter variable\">-p</span> <span class=\"token number\">9527</span>:9527 <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always pengzhile/pandora</code></pre>\n<pre><code>-p 9527:9527：可以更换，确保没有被占用即可\n--restart=always：自启动\n</code></pre>\n<ul>\n<li>查看虚拟机 ip 地址</li>\n</ul>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ifconfig</span></code></pre>\n<ul>\n<li>\n<p>访问：ip:9527，进入到登录页面，如图<br>\n<img src=\"https://img.miccai.top//imgs/2023-10-16-chatgpt/1.png\" alt=\"\"></p>\n</li>\n<li>\n<p>token 获取，请访问：<a href=\"https://chat.openai.com/api/auth/session\">获取 toked</a></p>\n</li>\n</ul>\n",
            "tags": [
                "chatGPT"
            ]
        },
        {
            "id": "https://ooooddddd.github.io/2023/10/12/RabbitMQ%E5%AD%A6%E4%B9%A0/",
            "url": "https://ooooddddd.github.io/2023/10/12/RabbitMQ%E5%AD%A6%E4%B9%A0/",
            "title": "RabbitMQ学习",
            "date_published": "2023-10-12T15:45:10.000Z",
            "content_html": "<h1 id=\"rabbitmq\"><a class=\"markdownIt-Anchor\" href=\"#rabbitmq\">#</a> RabbitMQ</h1>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h2>\n<ol>\n<li>\n<p>如图所示，运行 docker 镜像安装 rabbitmq<img src=\"/self/imgs/RabbitMQ/1.png\" alt=\"\"></p>\n</li>\n<li>\n<p>报错提示：网络未找到<br>\n<img src=\"/self/imgs/RabbitMQ/2.png\" alt=\"\"></p>\n</li>\n<li>\n<p>网络需要输入自己有的，之后运行命令，记得将用户名和密码设置为自己的</p>\n <pre class=\"language-Docker\" data-language=\"Docker\"><code class=\"language-Docker\">docker run -e RABBITMQ_DEFAULT_USER&#x3D;xxx -e RABBITMQ_DEFAULT_PASS&#x3D;xxxxx -v mq-plugins:&#x2F;plugins --name mq --hostname mq -p 15672:15672 -p 5672:5672 --network bridge -d rabbitmq:3.8-management&gt;</code></pre>\n</li>\n<li>\n<p>如何访问<br>\n<a href=\"http://192.168.110.92:15672/\"> http://192.168.110.92:15672/</a></p>\n</li>\n<li>\n<p>访问成功页面<img src=\"/self/imgs/RabbitMQ/3.png\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"快速入门\"><a class=\"markdownIt-Anchor\" href=\"#快速入门\">#</a> 快速入门</h2>\n<ol>\n<li>添加消息队列<img src=\"/self/imgs/RabbitMQ/4.png\" alt=\"\"></li>\n<li>发送消息到交换机（exchanges），然后交换机需要 binding 消息队列，否则消息无法发送。<img src=\"/self/imgs/RabbitMQ/5.png\" alt=\"\"></li>\n<li>总结：交换机没有存储消息的能力，只能转发消息</li>\n</ol>\n<h2 id=\"数据隔离\"><a class=\"markdownIt-Anchor\" href=\"#数据隔离\">#</a> 数据隔离</h2>\n<ol>\n<li>用户管理<img src=\"/self/imgs/RabbitMQ/6.png\" alt=\"\"></li>\n<li>虚拟主机可以完成数据隔离，如何新建虚拟主机<img src=\"/self/imgs/RabbitMQ/7.png\" alt=\"\"></li>\n<li>理论上讲，一个项目一个用户，一个虚拟主机</li>\n</ol>\n<h2 id=\"springamqp-java客户端\"><a class=\"markdownIt-Anchor\" href=\"#springamqp-java客户端\">#</a> SpringAMQP Java 客户端</h2>\n<h3 id=\"如何收发消息\"><a class=\"markdownIt-Anchor\" href=\"#如何收发消息\">#</a> 如何收发消息</h3>\n<ol>\n<li>引入 spring-boot-starter-amqp 依赖<img src=\"/self/imgs/RabbitMQ/8.png\" alt=\"\"></li>\n<li>相关配置<img src=\"/self/imgs/RabbitMQ/9.png\" alt=\"\"></li>\n<li>发消息，注入 RabbitTemplate<img src=\"/self/imgs/RabbitMQ/10.png\" alt=\"\"></li>\n<li>接收消息<img src=\"/self/imgs/RabbitMQ/11.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"workqueues模型\"><a class=\"markdownIt-Anchor\" href=\"#workqueues模型\">#</a> WorkQueues 模型</h3>\n<ol>\n<li>让多个消费者绑定一个队列，共同消费一个队列中的消息<img src=\"/self/imgs/RabbitMQ/12.png\" alt=\"\"></li>\n<li>循环发送消息<img src=\"/self/imgs/RabbitMQ/13.png\" alt=\"\"></li>\n<li>同时接收消息，并模拟不同的处理速度<img src=\"/self/imgs/RabbitMQ/14.png\" alt=\"\"></li>\n<li>设置 prefetch，控制消费者预取的消息数量<img src=\"/self/imgs/RabbitMQ/15.png\" alt=\"\"></li>\n<li>总结<img src=\"/self/imgs/RabbitMQ/16.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"fanout交换机\"><a class=\"markdownIt-Anchor\" href=\"#fanout交换机\">#</a> Fanout 交换机</h3>\n<ol>\n<li>Fanout 交换机会将接收到的消息广播到每一个跟其绑定的队列，所以也叫做广播模式。\n<blockquote>\n<p>1、一个交换机可以绑定多个队列 生产者发送的消息<br>\n 2、只能发送到交换机<br>\n 3、交换机把消息发送给绑定过的所有队列<br>\n 4、订阅队列的消费者都能拿到消息</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"direct交换机\"><a class=\"markdownIt-Anchor\" href=\"#direct交换机\">#</a> Direct 交换机</h3>\n<ol>\n<li>\n<p>Direct Exchange 会将接收到的消息根据规则路由到指定的 Queue，因此称为定向路由</p>\n<blockquote>\n<p>1、每一个队列在 bind 交换机时都设置一个 BindingKey<br>\n2、发布者发送消息时，指定消息的 RoutingKey<br>\n3、exchange 将消息路由到 BindingKey 与 RoutingKey 一致的队列<br>\n 4、如图所示<img src=\"/self/imgs/RabbitMQ/17.png\" alt=\"\"></p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"topic交换机\"><a class=\"markdownIt-Anchor\" href=\"#topic交换机\">#</a> Topic 交换机</h3>\n<ol>\n<li>Topic 与 Direct 功能类似，但 Topic 在 bindingkey 时更加灵活，可以使用通配符。</li>\n<li>BindingKey 一般是由一个或多个单词组成，以。分割。</li>\n<li>通配符规则：\n<blockquote>\n<p>#：匹配一个或多个单词<br>\n *：只匹配一个单词</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"声明队列和交换机\"><a class=\"markdownIt-Anchor\" href=\"#声明队列和交换机\">#</a> 声明队列和交换机</h3>\n<ol>\n<li>基于注解的声明方式<br>\n<img src=\"/self/imgs/RabbitMQ/18.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"消息转化器\"><a class=\"markdownIt-Anchor\" href=\"#消息转化器\">#</a> 消息转化器</h3>\n<ol>\n<li>配置 JSON 转换器<br>\n a. 先引入依赖<br>\n<img src=\"/self/imgs/RabbitMQ/19.png\" alt=\"\"><br>\n b. 配置消息转换器，在启动类添加 Bean<br>\n<img src=\"/self/imgs/RabbitMQ/20.png\" alt=\"\"><br>\n<img src=\"/self/imgs/RabbitMQ/21.png\" alt=\"\"></li>\n<li>发送消息与接收消息时，消息类型必须一致<img src=\"/self/imgs/RabbitMQ/22.png\" alt=\"\"><br>\n<img src=\"/self/imgs/RabbitMQ/23.png\" alt=\"\"></li>\n</ol>\n",
            "tags": [
                "RabbitMQ"
            ]
        }
    ]
}