{
    "version": "https://jsonfeed.org/version/1",
    "title": "橙熟 • All posts by \"javase\" tag",
    "description": "我的笔记",
    "home_page_url": "https://ooooddddd.github.io",
    "items": [
        {
            "id": "https://ooooddddd.github.io/2024/01/03/Javase%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/Javase%E7%9B%B8%E5%85%B3/",
            "title": "Javase相关",
            "date_published": "2024-01-03T12:00:41.000Z",
            "content_html": "<ul>\n<li><p>一、Java常用类、集合</p>\n<h4 id=\"1、Java的八大基本数据类型\"><a href=\"#1、Java的八大基本数据类型\" class=\"headerlink\" title=\"1、Java的八大基本数据类型\"></a>1、Java的八大基本数据类型</h4><ol>\n<li>整数：byte、short、int、long</li>\n<li>浮点数：float、double</li>\n<li>布尔：boolearn</li>\n<li>字符：char</li>\n</ol>\n<h4 id=\"2、String、StringBuilder、StringBuffer\"><a href=\"#2、String、StringBuilder、StringBuffer\" class=\"headerlink\" title=\"2、String、StringBuilder、StringBuffer\"></a>2、String、StringBuilder、StringBuffer</h4><ol>\n<li>String是不可变的，因为它被final修饰符修饰，并且String类的内部并没有暴露修改这个字符串的方法</li>\n<li>StringBuilder和StringBuffer则提供了很多修改字符串的方法，比如常用的 append()方法。</li>\n<li><strong>线程是否安全：</strong>String是不可变的，可以理解为常量，是线程安全的。StringBuffer和StringBuilder都定义了一些对字符串的基本操作。因为StringBuffer对这些方法加了同步锁，因此是线程安全的。而StringBuilder没有，所以StringBuilder不是线程安全的</li>\n<li><strong>总结</strong>：操作少量的数据时：使用String；单线程下操作大量数据：StringBuilder；多线程下操作大量数据：StringBuffer</li>\n<li>String使用<strong>字符串拼接</strong>时，也就是”+”时，底层会创建一个StringBuilder对象，调用append方法实现。最后会使用toString重新转为String。但是在循环内应该避免使用String拼接，因为编译器不会创建单个StringBuilder用以复用，会导致创建过多的StringBuilder对象。</li>\n</ol>\n<h4 id=\"3、ArrayList和linkedlist的区别\"><a href=\"#3、ArrayList和linkedlist的区别\" class=\"headerlink\" title=\"3、ArrayList和linkedlist的区别\"></a>3、ArrayList和linkedlist的区别</h4><ol>\n<li>都是线程不安全的</li>\n<li>底层数据结构：ArrayList使用的是Object数组；linkedlist底层使用的是双向循环链表</li>\n<li>插入删除：ArrayList采用的是数组存储，因此在插入和删除时的时间复杂度会受到元素位置的影响。而LinkedList则近似于O(1)</li>\n<li>是否支持快速随机访问：LinkedList不支持，而ArrayList则可以通过元素的序号快速获取元素对象。</li>\n<li>内存空间占用：ArrayList的空间浪费主要体现在list列表的末尾需要预留一定的冗余空间。而LinkedList则是需要额外存储直接后继与直接前驱。</li>\n</ol>\n<h4 id=\"4、ArrayList扩容\"><a href=\"#4、ArrayList扩容\" class=\"headerlink\" title=\"4、ArrayList扩容\"></a>4、ArrayList扩容</h4><p>以<strong>无参构造方法</strong>创建一个ArrayList时，是不会分配容量的，默认是<strong>0</strong>，只有在向ArrayList中add()第一个元素时，容量会得到扩容，默认为<strong>10</strong>，然后继续向里面添加元素，到<strong>11个</strong>元素时，此时已经超出当前容量，会进行扩容，10+10&#x2F;2&#x3D;15，当old容量为偶数时，新容量刚好就是old容量的1.5倍，奇数则会损失0.5的小数点。</p>\n<h4 id=\"5、HashMap-的-7-种遍历方式与性能分析\"><a href=\"#5、HashMap-的-7-种遍历方式与性能分析\" class=\"headerlink\" title=\"5、HashMap 的 7 种遍历方式与性能分析\"></a>5、HashMap 的 7 种遍历方式与性能分析</h4><ol>\n<li>迭代器:Iterator EntrySet、Iterator KeySet</li>\n<li>For Each:For EntrySet， For KeySet</li>\n<li>Lambda表达式</li>\n<li>Streams API</li>\n<li>多线程Streams API</li>\n</ol>\n<p>EntrySet的遍历性能最好，因为KeySet在循环时使用了map.get(key)，相当于又遍历了以便Map集合去查询Key所对应的值。在使用迭代器或者for循环时，其实已经遍历了一遍Map集合了。EntrySet只需要遍历一遍，然后就将对象的Key和Value都存放在了Entry对象中，因此再获取Key和Value就无需再遍历Map集合了</p>\n<p><strong>EntrySet</strong>：</p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">*</span><span class=\"token comment\">// 遍历*</span>\n   <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> entry <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p><strong>KeySet：</strong></p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">Integer</span> key <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h4 id=\"6、hashmap是否是线程安全的，常见的线程安全的集合\"><a href=\"#6、hashmap是否是线程安全的，常见的线程安全的集合\" class=\"headerlink\" title=\"6、hashmap是否是线程安全的，常见的线程安全的集合\"></a>6、hashmap是否是线程安全的，常见的线程安全的集合</h4><p>hashmap是线程不安全的，多线程下进行扩容会导致死循环，jdk1.7中hashmap的链表使用头插法插入元素，扩容时可能会导致环形链表的出现形成死循环，因此jdk1.8改为了尾插法，但是多线程的put操作，可能会导致元素的丢失问题。</p>\n<p>常见的线程安全的集合：</p>\n<p>hashtable，concurrentHashMap，vector、Stack。</p>\n<h4 id=\"7、HashMap的底层原理\"><a href=\"#7、HashMap的底层原理\" class=\"headerlink\" title=\"7、HashMap的底层原理\"></a>7、HashMap的底层原理</h4><p>在JDK1.8之前hashMap的底层数据结构是由数组+链表组成的，数组是HashMap的主体部分，而链表是为了解决哈希冲突而存在的。在JDK1.8中，是由数组+链表+红黑树组成的，当链表过长时，会严重影响HashMap的性能，因为链表的搜索时间复杂度是O（n），而红黑树则是O(logN)。因此，JDK1.8中引入了红黑树，在链表达到一定条件是会转化为红黑树。这个条件就是：当链表长度大于8，就会去检查数组的长度是否大于64，如果数组长度小于64，则进行数组的扩容，否则就会将链表转化为红黑树，以减少搜索时间。HashMap中采用的解决hash冲突的办法是链地址法。将哈希值相同的元素构成一个单链表，并将单链表的头结点存放在哈希表的第i个单元中。HashMap的默认加载因子是0.75，初始化数组的长度默认值是16，threshold是hashmap所能容纳的最大键值对数量&#x3D;加载因子*数组长度，当容量达到这个值时，数组就会进行扩容，扩大为原来的两倍，并将原来的对象放入新数组中。这里jdk1.8进行了适当的优化，无需再重新计算hash值，元素的位置在原来的位置或者是原来的位置+oldCap。</p>\n<p>jdk1.8之前，hashmap的插入方法是头插法，新插入的元素会插入到链表的头部。产生的问题如下：</p>\n<ul>\n<li>破坏了链表元素的插入顺序，可能不利于某些需要按照插入顺序进行遍历的场景</li>\n<li>容易形成环形链表的问题：由于头插法需要修改链表头，在多线程环境下可能会引起链表环形的问题，使得链表遍历时出现死循环</li>\n</ul>\n<h4 id=\"8、ConCurrentHashMap底层原理\"><a href=\"#8、ConCurrentHashMap底层原理\" class=\"headerlink\" title=\"8、ConCurrentHashMap底层原理\"></a>8、ConCurrentHashMap底层原理</h4><ol>\n<li>ConCurrentHashMap在HashMap的基础上加上的锁的机制，因此是线程安全的。在JDK1.7中，ConCurrentHashMap是由Segment分段数组结构和HashEntry数组结构组成的。即ConCurrentHashMap把哈希表分为了多个Segment小数组，而每个Segment就是一个类似于hashmap的结构，每一个hashmap的内部可以进行扩容，而segment的个数一旦初始化就不能再改变，默认值是16，也就可以认为其默认支持16个线程的并发。</li>\n<li>在jdk1.8中，其数据结构变成了数组+链表&#x2F;红黑树的组合，当链表冲突达到一定长度时，会转化为红黑树。在锁的实现上，抛弃了原本的Segment分段锁，采用了CAS + synchronized 对链表的头结点或红黑树的根节点进行加锁，将锁的级别控制在了更细粒度的级别，大大提高了并发量。</li>\n</ol>\n<h4 id=\"9、set、map、list\"><a href=\"#9、set、map、list\" class=\"headerlink\" title=\"9、set、map、list\"></a>9、set、map、list</h4><ol>\n<li><strong>set</strong>：不包含重复元素的集合，实现了set接口的类通常有HashSet、TreeSet等</li>\n<li><strong>Map：</strong>键值对的集合，key-value，不允许包含重复的key，但是可以包含重复的value</li>\n<li><strong>list</strong>：一个有序的集合，允许重复元素。ArrayList、LinkedList等。可以通过索引访问元素，按照插入顺序排序</li>\n</ol>\n<h4 id=\"10、HashMap、HashTable\"><a href=\"#10、HashMap、HashTable\" class=\"headerlink\" title=\"10、HashMap、HashTable\"></a>10、HashMap、HashTable</h4><ol>\n<li><strong>是否线程安全：</strong>HashMap不是线程安全的，另外两个是线程安全的。HashTable的线程安全是因为它内部的方法基本上都加了<code>synchronized</code>锁。ConCurrentHashMap是通过分段锁（jdk1.7），或者是CAS + synchronized（jdk1.8）对链表的头结点或者红黑树的根节点进行加锁实现的。</li>\n<li><strong>效率：</strong>HashMap效率更高，HashTable基本上已经不怎么用了，如果需要保证线程安全就选择ConCurrentHashMap</li>\n<li><strong>Null Key 和 Null Value</strong>：HashMap支持Null Key 和 Null Value，但是Null Key 只能存在一个，Null Value可以有多个。HashTable并不支持 Null Key 和Null Value，否则会报错NPE（空指针异常）</li>\n<li><strong>初始容量：</strong><ul>\n<li>不指定：HashTable默认是11，每次扩容变为原来的 2n+1。 HashMap默认16，每次扩容变为原来的2倍</li>\n<li>指定：HashTable直接用指定的。HashMap则会扩充为2的幂次方大小 10 –&gt; 16。为什么总是2的幂次方，因为 取余（%）操作可以利用 二进制位与（&amp;）操作代替。（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）</li>\n</ul>\n</li>\n<li><strong>底层数据结构：</strong>HashTable没有链表转为红黑树的操作</li>\n</ol>\n<h4 id=\"11、HashMap-和-HashSet-区别\"><a href=\"#11、HashMap-和-HashSet-区别\" class=\"headerlink\" title=\"11、HashMap 和 HashSet 区别\"></a>11、HashMap 和 HashSet 区别</h4><ol>\n<li>HashSet的底层就是HashMap 实现的。</li>\n<li>HashSet仅存储值，HashMap存储键值对 Key-Value</li>\n<li>HashSet add方法添加元素，HashMap则add（key，value）方法添加元素</li>\n</ol>\n<h3 id=\"二、并发编程\"><a href=\"#二、并发编程\" class=\"headerlink\" title=\"二、并发编程\"></a>二、并发编程</h3><h4 id=\"1、volatile关键字\"><a href=\"#1、volatile关键字\" class=\"headerlink\" title=\"1、volatile关键字\"></a>1、volatile关键字</h4><ol>\n<li>volatile保证变量对所有线程的可见性，当volatile变量被修改时，新值对所有变量会立即更新。即多线程环境下使用volatile修饰的变量的值一定是最新的。</li>\n<li>禁止指令重排序</li>\n</ol>\n<h4 id=\"2、synchronized关键字\"><a href=\"#2、synchronized关键字\" class=\"headerlink\" title=\"2、synchronized关键字\"></a>2、synchronized关键字</h4><p>主要是用于解决多个线程之间访问资源的同步性，可以保证被其修饰的方法或代码块在任意时刻只能有一个线程执行。（悲观锁的思想）</p>\n<p>修饰实例方法：给当前对象实例加锁，进入同步代码块之前需要获取当前对象实例的锁</p>\n<p>修饰静态方法：给当前的类加锁，会作用于当前类的所有对象实例。</p>\n<p>修饰代码块：既可以锁定对象实例，也可以锁定类，以括号中的代码为准</p>\n<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>\n</ul>\n<p><strong>底层实现：</strong>主要通过两个指令实现，monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块的结束位置。在执行monitorenter指令时，线程尝试获取锁也就是获取对象监视器monitor的持有权，对象监视器是由c++实现的，每个对象中都内置了一个对象监视器对象。如果锁的计数器为0，则表示可以被获取，获取后将锁计数器设为1，业务执行完毕后通过monitorexit指令释放锁，将锁的计数器设为0，然后其他线程才可以尝试获取锁。如果获取锁失败，当前线程需要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<h4 id=\"3、乐观锁-与-悲观锁\"><a href=\"#3、乐观锁-与-悲观锁\" class=\"headerlink\" title=\"3、乐观锁 与 悲观锁\"></a>3、乐观锁 与 悲观锁</h4><ol>\n<li><strong>悲观锁：</strong>总是假设最坏的情况，认为资源每次被访问的时候都会出问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，共享资源每次只给一个线程使用，其他线程都会阻塞。高并发场景下会增加系统开销，因为线程阻塞会导致系统的上下文切换。还有可能造成死锁的问题。</li>\n<li><strong>乐观锁：</strong>乐观锁总是假设最好情况，认为共享资源每次被访问都不会出现问题，线程无需等待，只是在提交修改的时候去验证对应的数据是否被其他线程修改了（<strong>版本号或者CAS算法</strong>）</li>\n<li><strong>使用场景</strong>：悲观锁适用于：写操作比较多的场景 乐观锁适用于：读操作较多的场景</li>\n<li><strong>乐观锁的实现：</strong><ol>\n<li><strong>版本号机制：</strong>在数据表中加上一个数据版本号的字段，表示数据被修改的次数，要更新数据前读取该版本，更新操作完成，提交更新时再次读取版本号的值，与之前的值相等才更新。</li>\n<li><strong>CAS算法：</strong>Compare And Swap（比较与交换）思想：使用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。乐观锁产生的问题<ol>\n<li>ABA问题：初次读取值为A，要更新时再检查依然是A，但是这个过程中被改为了B，又重新改为了A。</li>\n<li>CAS自旋操作：就是执行不成功就一直循环执行直到成功为止，如果长时间循环，会对CPU带来较大的开销</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4、线程死锁\"><a href=\"#4、线程死锁\" class=\"headerlink\" title=\"4、线程死锁\"></a>4、线程死锁</h4><p>多个线程同时被阻塞，产生死锁的四个必要条件：</p>\n<ol>\n<li>互斥条件，该资源在任意一个时刻只能由一个线程占用</li>\n<li>请求与保持：一个线程因为请求资源被阻塞时，不会去是释放已经占用的资源</li>\n<li>不剥夺条件：在线程未主动释放资源之前，不能被其他线程强行剥夺，只能使用完毕自行释放</li>\n<li>循环等待：若干线程在等待资源时形成了首尾相接的情况</li>\n</ol>\n<p>预防死锁：</p>\n<ol>\n<li>破坏互斥条件：一次性申请所有资源</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请资源时如果被阻塞，就主动释放它所占用的资源</li>\n<li>按序申请资源，破坏循环等待条件</li>\n</ol>\n<p>避免死锁：</p>\n<p>借助算法，如银行家算法等对资源分配进行计算评估，使其进入安全状态。</p>\n<p>还有哪些关键字</p>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231225103712047.png\" alt=\"image-20231225103712047\"></p>\n<h4 id=\"5、说说线程的生命周期和状态\"><a href=\"#5、说说线程的生命周期和状态\" class=\"headerlink\" title=\"5、说说线程的生命周期和状态?\"></a>5、说说线程的生命周期和状态?</h4><p>New:初始状态，线程被创建之后但没有被调用Start()</p>\n<p>RUNNABLE:运行状态，线程被调用了Start()等待运行的状态。</p>\n<p>​\t在操作系统层面是有：READY和Running状态的区分，但是在JVM层面只能看到RUNNABLE状态</p>\n<p>BLOCK:阻塞状态，需要等待锁释放</p>\n<p>WAITING:等待状态，需要其他线程通知或中断</p>\n<p>TIME_WAITING:超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待</p>\n<p>TERMINATED：终止状态，表示该线程运行完毕</p>\n<h4 id=\"6、线程的上下文切换\"><a href=\"#6、线程的上下文切换\" class=\"headerlink\" title=\"6、线程的上下文切换\"></a>6、线程的上下文切换</h4><p>每个线程在执行过程中，会有自己的运行条件和状态(也称为上下文)，当出现如下情况时，线程会从占用CPU的状态退出。主动让出CPU，比如调用了sleep、wait等，时间片用完、或者请求 IO，线程被阻塞。然后就会发生线程切换，需要保存当前线程的上下文，用于线程下次占用CPU的时候恢复线程。并加载下一个将要占用CPU的线程的上下文。如果切换频繁就会造成系统的整体效率低下</p>\n<h4 id=\"7、线程池的核心参数：\"><a href=\"#7、线程池的核心参数：\" class=\"headerlink\" title=\"7、线程池的核心参数：\"></a>7、线程池的核心参数：</h4><ol>\n<li>corePoolSize：核心线程大小，线程池一直运行，核心线程就不会停止</li>\n<li>maximumPoolSize：线程池最大线程数量，</li>\n<li>keepAliveTime：非核心线程的心跳时间，在该时间内没有运行任务，就会消亡</li>\n<li>workQueue：新任务来的时候判断当前运行的线程数量是否达到核心线程数，如果达到，任务就会被存放到阻塞队列。</li>\n<li>unit：keepAliveTime的时间单位</li>\n<li>ThreadFactory：线程工厂，创建新线程会用到</li>\n<li>defaultHandler：饱和策略。</li>\n</ol>\n<h4 id=\"8、Java-实现并发的几种方法\"><a href=\"#8、Java-实现并发的几种方法\" class=\"headerlink\" title=\"8、Java 实现并发的几种方法\"></a>8、Java 实现并发的几种方法</h4><ol>\n<li>synchronized关键字</li>\n<li>Volatile关键字</li>\n<li>实现Runnable接口创建线程</li>\n<li>继承Thread类创建线程</li>\n<li>线程池</li>\n<li>stream流也可以</li>\n</ol>\n<h4 id=\"9、ThreadLocal\"><a href=\"#9、ThreadLocal\" class=\"headerlink\" title=\"9、ThreadLocal\"></a>9、ThreadLocal</h4><h3 id=\"三、JVM\"><a href=\"#三、JVM\" class=\"headerlink\" title=\"三、JVM\"></a>三、JVM</h3><h4 id=\"1、JVM内存分区模型\"><a href=\"#1、JVM内存分区模型\" class=\"headerlink\" title=\"1、JVM内存分区模型\"></a>1、JVM内存分区模型</h4><p>主要分为以下几个区域：</p>\n<ol>\n<li><strong>程序计数器</strong>：每个线程都有自己的程序计数器，用于指示当前线程执行的字节码指令的行号，分支、循环、跳转、异常处理等基础功能都依赖这个指示器完成。每个线程都有一个独立的程序计数器，确保线程切换后能恢复到正确的执行位置。</li>\n<li><strong>虚拟机栈</strong>：也称为Java方法栈，用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息。每个线程在执行一个方法时，都会为该方法分配一个栈桢，并将其压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈。</li>\n<li><strong>本地方法栈</strong>：与虚拟机栈类似，用于存储本地方法的执行信息</li>\n<li><strong>堆</strong>：用于存储对象实例，是JVM中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的对象实例都有一个标记用于指示对象是否存活。垃圾回收器会周期性地回收那些没有被标记为存活的对象。</li>\n<li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即编译器编译后的代码等数据</li>\n<li><strong>运行时常量池</strong>：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用的常量池。</li>\n</ol>\n<h4 id=\"2、JVM垃圾回收算法\"><a href=\"#2、JVM垃圾回收算法\" class=\"headerlink\" title=\"2、JVM垃圾回收算法\"></a>2、JVM垃圾回收算法</h4><p>常见的垃圾回收算法有以下几种类型：</p>\n<ol>\n<li><strong>标记——清除算法：</strong>分为标记和清除两个阶段。标记阶段遍历所有活动对象并打上标记，清除阶段将未被标记的对象删除。优点是不需要连续的内存空间，缺点是清除后可能会产生内存碎片</li>\n<li><strong>复制算法：</strong>将可用内存分为两块，只使用其中一块，当一块满了，将存活对象复制到另一块未被使用的空间，然后清除使用的那块。优点是：简单高效，不会产生内存碎片。缺点是可用内存缩小为原来的一半。不适合老年代：存活对象数量比较大，复制性能很差。</li>\n<li><strong>标记——整理算法：</strong>与标记——清除类似，在标记阶段与其相似，但是在清除阶段将存活对象整理到内存的一端，然后清除端边界外的所有对象。优点是不会产生内存碎片，缺点是比较慢。</li>\n<li><strong>分代收集算法：</strong>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活的时间将内存分为几个区域，每个区域采用不同的回收策略。新生代、老年代分别采取不同的回收算法。<ol>\n<li>新生代：分为一个Eden区和两个Survivor 区，当Eden区没有空间时，虚拟机将发起一次Minor GC（只对新生代进行垃圾收集），执行完后，如果对象能够存在Eden区的话，就会直接在Eden分配内存。对象每在Survior区熬过一次，年龄标志就增长1，增长到一定程度就会晋升到老年代中，这个值默认是15</li>\n<li>大对象和长期存活的对象将会进入老年代，Old GC，只对老年代进行垃圾收集</li>\n<li>Mixed GC：混合收集</li>\n<li>Full GC，收集整个Java堆和方法区</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3、双亲委派模式\"><a href=\"#3、双亲委派模式\" class=\"headerlink\" title=\"3、双亲委派模式\"></a>3、双亲委派模式</h4><p>是Java类加载器在加载类时所采用的的一种设计模式。这种模式的核心思想是：当一个类加载器收到类加载请求时，首先不会自己尝试加载，而是将请求委派给它的父类加载器。依次递归，指导最顶层的启动类加载器；如果父类加载器无法加载该类，子类才尝试自己加载。</p>\n<p>主要作用：</p>\n<ol>\n<li><strong>避免类的重复加载</strong>：通过委派给父类加载器，同一个类不会被多个类加载器重复加载。有助于节省内存资源</li>\n<li><strong>保护Java核心类库</strong>：由于双亲委派制的存在，用户自定义的类加载器无法直接加载Java核心类库，java.lang.String等。能够确保Java核心类库的安全性。例如当我们自定义了一个java.lang包，并且定义了一个类String，一旦运行代码，需要加载这个类的时候，就会向上一层层的委派到顶层的<strong>启动类加载器</strong>，顶层的引导类加载器会加载Java核心类库中的java.lang.String，该类中没有main方法，因此程序提示在<strong>java.lang.String类中找不到main方法</strong><ol>\n<li><img src=\"https://ask.qcloudimg.com/http-save/yehe-2219188/k9iysve4gq.png\" alt=\"img\"></li>\n</ol>\n</li>\n<li><strong>维护类加载器的层次结构</strong>：双亲委派模式使得各级类加载器可以按照⼀定的层次结构来组织和管理。这有助于 降低类加载器的复杂性，简化类加载过程。</li>\n</ol>\n<h4 id=\"4、JVM-的垃圾回收机制\"><a href=\"#4、JVM-的垃圾回收机制\" class=\"headerlink\" title=\"4、JVM 的垃圾回收机制\"></a>4、JVM 的垃圾回收机制</h4><p>在Java中，程序员不需要显示的区释放一个对象的内存，而是由虚拟机自行执行。想要知道JVM的垃圾回收机制，首先我们得知道JVM是如何给一个对象分配内存的。</p>\n<ol>\n<li>大多数情况下，对象会在新生代中的Eden区进行分配内存，当Eden区没有足够空间时，会进行一次Minor GC。此时会将Eden区域的内容转移到Survivor中去，如果该空间不足，会通过分配担保机制将新生代的对象提前转移到老年代中。</li>\n<li>大对象也会直接进入老年代中，如字符串、数组等</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象分配一个Age计数器，初始在Eden区为0，经过一次Minor GC还存活，并且可以被Survivor区域所容纳，就会移动到Survivor区，Age计数器加一。每存活过一次Minor GC，Age计数器就会 + 1。到达15时，会转移到老年代中。</li>\n</ol>\n<ul>\n<li>如何判断是否需要进行回收：<ol>\n<li>进行可达性分析：通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</li>\n<li>然后通过一些垃圾回收算法进行垃圾回收。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5、新生代和老生代怎么区分的\"><a href=\"#5、新生代和老生代怎么区分的\" class=\"headerlink\" title=\"5、新生代和老生代怎么区分的\"></a>5、新生代和老生代怎么区分的</h4><h3 id=\"四、计算机网络\"><a href=\"#四、计算机网络\" class=\"headerlink\" title=\"四、计算机网络\"></a>四、计算机网络</h3><h4 id=\"TCP连接的三次握手\"><a href=\"#TCP连接的三次握手\" class=\"headerlink\" title=\"TCP连接的三次握手\"></a>TCP连接的三次握手</h4><p>最开始，客户端和服务端都处于<code>Close</code>状态，先是服务端主动监听某个端口，进入<code>Listen</code>状态。</p>\n<ol>\n<li>第一次握手，由客户端向服务端发送建立连接的请求，向服务端发送一个同步报文，同时初始化一个随机数作为<strong>客户端的初始序列号seq&#x3D;x</strong>，并且进入SYN_SENT状态，等待服务器的确认。服务端接到请求之后，可以确认自己的接受能力和客户端的发送能力正常。</li>\n<li>第二次握手，服务端受到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文，确认号ack&#x3D;x+1，同时初始化一个随机数作为<strong>服务端的初始序列号seq&#x3D;y</strong>，此时服务器进入SYN_RECV状态。客户端收到这次报文后，能够确认自己的收、发能力，以及服务端的收、发能力都正常。</li>\n<li>客户端收到服务端的确认之后，向服务端发送一个确认报文，确认号ack&#x3D;y+1，序列号seq &#x3D; x+1，服务端接收到这次报文之后能够确认自己的发送能力和客户端的接收能力都正常，完成三次握手，第三次握手还可以携带数据。</li>\n</ol>\n<h4 id=\"为什么是三次握手？\"><a href=\"#为什么是三次握手？\" class=\"headerlink\" title=\"为什么是三次握手？\"></a>为什么是三次握手？</h4><ol>\n<li>三次握手可以阻止重复历史连接的初始化</li>\n<li>三次握手才可以同步双方的初始序列号</li>\n<li>三次握手才可以保证双方均具有接收和发送的能力</li>\n</ol>\n<h4 id=\"TCP连接的四次挥手\"><a href=\"#TCP连接的四次挥手\" class=\"headerlink\" title=\"TCP连接的四次挥手\"></a>TCP连接的四次挥手</h4><p>第一次挥手，客户端向服务端发送连接释放报文FIN，主动关闭连接，同时等待服务端的确认，序列号&#x3D;客户端上次发送报文的最后一个字节的序号+1，确认号是服务端上次发送的报文的最后一个字节的序号+1</p>\n<p>第二次挥手：服务端接收到连接释放的报文后，立即发出确认报文，序列号等于刚才客户端的确认号，确认号等于刚才客户端的序列号+1。此时TCP处于半关闭状态，服务端还可以继续向客户端发送没有发完的数据，发送完毕后。</p>\n<p>第三次挥手，服务端向客户端发送连接释放报文FIN，主动关闭连接，同时等待客户端的确认。序列号&#x3D;服务端上次发送报文的最后一个字节的序号+1，与第二次挥手相同，因为这段时间客户端没有发送数据</p>\n<p>第四次挥手：客户端收到服务端的释放连接报文后，立即发送确认报文，序列号等于&#x3D;上面的确认号+1，确认号&#x3D;上面的序列号+1，服务端进入Close状态。然后客户端进入TIME_WAIT状态，等待2*MSL（最长报文寿命），之后才会进入Close状态。</p>\n<h5 id=\"为什么需要等待2-MSL：\"><a href=\"#为什么需要等待2-MSL：\" class=\"headerlink\" title=\"为什么需要等待2*MSL：\"></a>为什么需要等待2*MSL：</h5><p>​\t确保第四次握手，客户端的确认报文能够到达服务端，从而使服务端正常关闭连接。如果没有正常到达服务端，服务端会超时重传FIN，此时如果客户端已经断开连接，那么就无法响应服务端的请求，服务端无法正常收到确认报文，无法正常关闭连接。2*MSL&#x3D;客户端确认报文1MSL+服务端重传FIN报文1MSL，这样能够确保服务端能够正常关闭。</p>\n<h3 id=\"职业规划\"><a href=\"#职业规划\" class=\"headerlink\" title=\"职业规划\"></a>职业规划</h3><ul>\n<li>能在1-2年完全胜任岗位职责，有优秀的产出</li>\n<li>2-3年成为岗位熟手，自身优秀的同时能带教新人</li>\n<li>3-5年成为业务骨干或一线经理，能带领小团队协作完成任务</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Javase"
            ]
        }
    ]
}