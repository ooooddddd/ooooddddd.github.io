{
    "version": "https://jsonfeed.org/version/1",
    "title": "橙熟 • All posts by \"spring\" tag",
    "description": "我的笔记",
    "home_page_url": "https://ooooddddd.github.io",
    "items": [
        {
            "id": "https://ooooddddd.github.io/2024/01/03/Spring%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/Spring%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/",
            "title": "Spring框架相关",
            "date_published": "2024-01-03T12:02:34.000Z",
            "content_html": "<h3 id=\"一、IOC和AOP\"><a href=\"#一、IOC和AOP\" class=\"headerlink\" title=\"一、IOC和AOP\"></a>一、IOC和AOP</h3><h4 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h4><ol>\n<li>控制翻转，IOC指的是将对象的创建和依赖注入由应用代码转移到了Spring容器中，原本需要程序员手动创建对象，依赖，现在翻转给了Spring帮忙实现。降低了应用代码的复杂度，提高了代码的可重用性和可维护性。</li>\n<li>BeanFactory就是IOC容器，由容器进行创建Bean对象</li>\n</ol>\n<h4 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h4><p>面向切面编程，正常来说，我们的代码中不仅需要业务逻辑部分，还需要日志，安全，事务等，但是如果有个业务需要经常用到，就比如说登陆校验吧，用户可能在看购物车需要校验其是否登陆，在看订单信息也需要校验是否登陆，如果使用AOP将这个校验的逻辑抽离出来，实现一个全局统一登陆校验，就不用再每个方法里面单独进行校验了。</p>\n<h3 id=\"二、IOC的实现机制\"><a href=\"#二、IOC的实现机制\" class=\"headerlink\" title=\"二、IOC的实现机制\"></a>二、IOC的实现机制</h3><ol>\n<li>定义Bean：在Spring IOC中，所有的对象都被看作是Bean，需要在配置文件使用注解的方式中进行定义和配置</li>\n<li>创建Bean工厂，在Spring 中，BeanFactory 负责管理Bean的创建、组装和销毁等任务。Spring IOC 容器就是Bean工厂的一种实现。</li>\n<li>读取配置文件：Spring IOC 容器会读取配置文件或者使用注解的方式来获取Bean的定义和配置信息</li>\n<li>创建Bean实例：根据配置文件相关信息通过反射技术来创建Bean的实例，并保存到容器中</li>\n<li>组装Bean：Spring IOC 容器根据配置文件中的信息，将不同的Bean实例组装起来，形成一个完整的应用程序。</li>\n<li>注入依赖：根据配置文件的信息，自动为Bean注入依赖的对象或者值</li>\n<li>提供Bean实例：通过Spring IOC 容器获取需要的Bean实例，从而调用其中的方法或者属性等。</li>\n</ol>\n<h4 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h4><p>创建的过程：首先实例化Bean，并设置Bean的属性，根据其实现的Aware接口设置依赖信息，接下来会陆续调用一些方法：</p>\n<ol>\n<li>BeanPostProcess的postProcessBeforeInitialization方法，完成初始化前的自定义操作</li>\n<li>afterPropertiesSet方法做一些属性被设定后的自定义操作</li>\n<li>调用Bean的Init方法，做一些初始化相关操作</li>\n<li>然后再调用postProcessAfterInitialization去完成bean初始化之后的相关自定义操作。这四个方法类似于AOP</li>\n</ol>\n<p>此时，Bean初始化完成，可以使用这个Bean了</p>\n<p>销毁过程：调用DisposableBean的destory()方法，如果实现了自定义的销毁方法，也去调用。其中单例Bean会随着容器的销毁而销毁，多例的Bean则是通过JVM里的垃圾回收器负责回收的。</p>\n<h3 id=\"三、Spring框架中的设计模式\"><a href=\"#三、Spring框架中的设计模式\" class=\"headerlink\" title=\"三、Spring框架中的设计模式\"></a>三、Spring框架中的设计模式</h3><ul>\n<li>单例模式：Spring中的Bean默认是单例模式，每个对象实例只创建一次</li>\n<li>工厂模式：Spring使用工厂模式通过BeanFactory创建并管理Bean</li>\n<li>代理模式：Spring Aop基于动态代理技术，使用代理模式实现切面编程</li>\n</ul>\n<h3 id=\"四、-Autowired-和-Resources的区别\"><a href=\"#四、-Autowired-和-Resources的区别\" class=\"headerlink\" title=\"四、@Autowired 和 @Resources的区别\"></a>四、@Autowired 和 @Resources的区别</h3><ul>\n<li>@Autowired：Spring框架的注入Bean的注解，默认的注入方式是ByType（根据类型进行匹配），当一个接口存在多个实现类时，需要通过@Qualifier注解来指定名称。支持在构造函数、方法、字段和参数上使用。</li>\n<li>@Resources：jdk提供的注解注入方式，默认是ByName（根据名称进行匹配），如果一个接口有多个实现类，可以通过name属性显式指定名称。主要用于字段和方法的注入，不支持在构造函数上使用。</li>\n</ul>\n<h3 id=\"五、Spring处理线程并发问题，ThreadLocal\"><a href=\"#五、Spring处理线程并发问题，ThreadLocal\" class=\"headerlink\" title=\"五、Spring处理线程并发问题，ThreadLocal\"></a>五、Spring处理线程并发问题，ThreadLocal</h3><p>ThreadLocal类：提供了线程本地变量的功能，可以让每个线程拥有自己的<strong>变量副本</strong>，从而避免了多个线程之间的共享问题。但是ThreadLocal使用时需要注意<strong>内存泄漏</strong>的问题。</p>\n<p>在豆丁点评项目中，用户登陆之后，将用户的脱敏信息通过set方法存放到了ThreadLocal中，使用时可以通过get方法获取，退出登录时使用remove方法将其移除。</p>\n<p><strong>原理：</strong>首选，Thread类中存在两个ThreadLocalMap类型的变量，可以将ThreadLocalMap理解为ThreadLocal类实现的定制化HashMap。最终的变量是存储在了当前线程的ThreadLocalMap中，并不是ThreadLocal上，ThreadLocalMap可以存储以ThreadLocal为 key，Object对象为value的键值对。</p>\n<p><strong>内存泄露问题：</strong>ThreadLocalMap中的Key是ThreadLocal的弱引用，而value是强引用。所有在垃圾回收时，key被清理掉时，value不会被清理。此时ThreadLocalMap中就会出现key为null的Entry，如果不做任何措施，value无法被GC回收，此时就会出现内存泄漏。因此ThreadLocalMap在调用set，get和remove方法的时候，会主动清理key为null的记录。</p>\n<h3 id=\"六、Spring-⽀持哪⼏种事务管理类型\"><a href=\"#六、Spring-⽀持哪⼏种事务管理类型\" class=\"headerlink\" title=\"六、Spring ⽀持哪⼏种事务管理类型\"></a>六、Spring ⽀持哪⼏种事务管理类型</h3><ol>\n<li>编程式事务管理</li>\n<li>声明式事务管理：</li>\n<li>注解式事务管理：@Transactional注解</li>\n</ol>\n<h3 id=\"七、Spring-Boot-的主要优点\"><a href=\"#七、Spring-Boot-的主要优点\" class=\"headerlink\" title=\"七、Spring Boot 的主要优点\"></a>七、Spring Boot 的主要优点</h3><ol>\n<li>开发基于Spring的应用程序简单多了，提高了整体的开发速度</li>\n<li>Spring Boot 不需要编写大量的xml配置</li>\n<li>Spring Boot 提供嵌入式HTTP服务器，如Tomcat，可以更加轻松地开发web应用程序</li>\n<li>Spring Boot Starters 是⼀系列依赖关系的集合，因为它的存在，项⽬的依赖之 间的关系对我们来说变的更加简单了</li>\n</ol>\n<h3 id=\"八、-SpringBootApplication注解\"><a href=\"#八、-SpringBootApplication注解\" class=\"headerlink\" title=\"八、@SpringBootApplication注解\"></a>八、@SpringBootApplication注解</h3><ol>\n<li>可以把SpringBootApplication注解看作是@Configuration、@EnableAutoConfiguration、@ComponentScan三个注解的集合。</li>\n<li>@EnableAutoConfiguration注解：开启SpringBoot的自动配置机制</li>\n<li>@ComponentScan：扫描被@Component（Service、controller、Repository）注解修饰的Bean，注解默认会扫描该类所在的包下的所有的类</li>\n<li>@Configuration：允许Spring上下文中注册额外的bean或者导入其他配置类。</li>\n</ol>\n<h3 id=\"九、开发-RESTful-Web-服务常⽤的注解有哪些\"><a href=\"#九、开发-RESTful-Web-服务常⽤的注解有哪些\" class=\"headerlink\" title=\"九、开发 RESTful Web 服务常⽤的注解有哪些\"></a>九、开发 RESTful Web 服务常⽤的注解有哪些</h3><h4 id=\"RESTful-风格是什么\"><a href=\"#RESTful-风格是什么\" class=\"headerlink\" title=\"RESTful 风格是什么\"></a>RESTful 风格是什么</h4><p>简单来讲就是：RESTful API 可以让程序员看到 URL+Http Method 就知道这个URL是干什么的，看到了响应码，就知道请求结果是怎样的。</p>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231228102018854.png\" alt=\"image-20231228102018854\"></p>\n<h4 id=\"Spring-Bean相关\"><a href=\"#Spring-Bean相关\" class=\"headerlink\" title=\"Spring Bean相关\"></a>Spring Bean相关</h4><ul>\n<li>@Autowired：自动注入对象到类中进行使用，被注入的类需要被Spring容器进行管理</li>\n<li>@RestController：表示这是一个控制器Bean，并且将函数的返回值直接填入Http响应体中，是Rest风格的控制器</li>\n</ul>\n<h4 id=\"处理HTTP请求\"><a href=\"#处理HTTP请求\" class=\"headerlink\" title=\"处理HTTP请求\"></a>处理HTTP请求</h4><ul>\n<li>@GetMapping：get请求，请求参数是放在了路径url中，不太安全，并且会受到url长度的限制，get一般用于资源的获取，读取数据。</li>\n<li>@PostMapping：post请求，通过request body传递参数，可传递的数据类型更多，更安全。post一般用于修改和写入数据。</li>\n<li>@PutMapping：put请求</li>\n<li>@DeleteMapping：delete请求</li>\n</ul>\n<h4 id=\"前后端传递值\"><a href=\"#前后端传递值\" class=\"headerlink\" title=\"前后端传递值\"></a>前后端传递值</h4><ul>\n<li><p>@PathVariable 和 @RequestParam，PathVariable用于获取路径参数，@RequestParam用于获取查询参数</p>\n<ul>\n<li><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231228104008749.png\" alt=\"image-20231228104008749\"></li>\n</ul>\n</li>\n<li><p>@RequestBody，用于读取一个Json格式的数据，并将其绑定到一个Java对象上去。一个方法只能有一个@RequestBody，但可以有多个**<code>@RequestParam</code>和<code>@PathVariable</code>**</p>\n</li>\n</ul>\n",
            "tags": [
                "Spring"
            ]
        }
    ]
}