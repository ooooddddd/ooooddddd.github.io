{
    "version": "https://jsonfeed.org/version/1",
    "title": "橙熟 • All posts by \"点评\" tag",
    "description": "我的笔记",
    "home_page_url": "https://ooooddddd.github.io",
    "items": [
        {
            "id": "https://ooooddddd.github.io/2024/01/03/%E8%B1%86%E4%B8%81%E7%82%B9%E8%AF%84%E7%9B%B8%E5%85%B3/",
            "url": "https://ooooddddd.github.io/2024/01/03/%E8%B1%86%E4%B8%81%E7%82%B9%E8%AF%84%E7%9B%B8%E5%85%B3/",
            "title": "豆丁点评相关",
            "date_published": "2024-01-03T12:06:12.000Z",
            "content_html": "<pre><code>基于Redis + Spring Boot实现的类点评APP，实现了用户登录、查询店铺、优惠券秒杀、发表点评、推送点评、附近商户、用户签到的完整业务流程。\n</code></pre>\n<p>项目的难点：主要是事务的问题</p>\n<h3 id=\"用户登陆：\"><a href=\"#用户登陆：\" class=\"headerlink\" title=\"用户登陆：\"></a><strong>用户登陆</strong>：</h3><p>使用 Redis 实现分布式 Session，解决集群间登录态同步问题；使用 Hash 代替 String 来存储用户信息，节约内存的同时有利于单个字段的修改。</p>\n<p><strong>科室查询</strong>：将高访问量的科室信息提前缓存到了redis中，降低数据库压力的同时提高了查询性能。同时，为了之后方便其他业务使用缓存功能，使用<strong>泛型 + 函数式</strong>编程实现了通用缓存的静态方法，并解决了</p>\n<ol>\n<li><strong>缓存穿透</strong>（用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力），是通过缓存 <strong>null</strong> 值解决，但是会浪费内存空间，所以后续准备改为布隆过滤器</li>\n<li><strong>缓存雪崩</strong>（指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。）：<ul>\n<li>在原有的失效时间的基础上添加一个随机值(1-5分钟)</li>\n<li>搭建redis集群提高服务的高可用性</li>\n<li>多级缓存</li>\n<li>降级限流策略</li>\n</ul>\n</li>\n<li><strong>缓存击穿（热点Key问题）</strong>【被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。】（利用<strong>互斥锁</strong>或者<strong>逻辑过期</strong>实现）<ol>\n<li>逻辑过期时间（不保证一致性，适用于注重用户体验，而非注重数据一致性的场景）：先从redis中查询缓存，如果未命中，直接返回 null，如果命中，判断其逻辑过期时间是否过期，未过期，直接返回数据。已过期，则需要进行缓存重建，先尝试获取互斥锁，获取成功，开启独立线程去完成缓存重建的工作。如果获取互斥锁失败，则不进行等待，直接返回已经过期的数据即可。性能较好。</li>\n</ol>\n</li>\n<li>双写一致性</li>\n</ol>\n<p><img src=\"https://img.miccai.top/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20231229142644881.png\" alt=\"image-20231229142644881\"></p>\n<h3 id=\"优惠券秒杀功能：\"><a href=\"#优惠券秒杀功能：\" class=\"headerlink\" title=\"优惠券秒杀功能：\"></a><strong>优惠券秒杀功能</strong>：</h3><p>使用Redis + Lua脚本实现对用户下单资格的预检，同时用乐观锁解决预约下单产生的超号问题。</p>\n<p>乐观锁：不加锁，在更新时判断是否有其他线程在修改（性能好，但成功率低）</p>\n<ol>\n<li>版本号法：额外记录一个 version 值，在扣减库存的同时变化这个值，通过这个值是否变化来检验</li>\n<li>库存直接作为版本号，在更新时加一条对库存的判断</li>\n</ol>\n<p>使用Redisson分布式锁解决了在集群模式下一人一单的线程安全问题。</p>\n<ol>\n<li>首先是想通过加 synchronized 锁来解决一人一单，将 synchronized 锁加到方法的外面，先获取锁，再通过代理对象去提交事务，最后释放锁，是线程安全的。但这样操作又会出现 spring 事务失效的问题，因此需要先获取事务的代理对象，然后再使用代理对象去调用方法。需要在spingboot的启动类上面添加@EnableAspectJAutoProxy(exposeProxy &#x3D; true)注解。</li>\n<li>但是这个synchronized 锁在分布式集群模式下，会失效，因为synchronized关键字的作用域其实是一个进程，在这个进程下面的所有线程都能够进行加锁，但是在集群模式下属于多台服务器，多进程</li>\n<li>通过使用Redisson提供的锁对象，利用 userId创建锁对象，来控制一人一单。</li>\n</ol>\n<h4 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h4><p>使用Redis Stream结构作为消息队列，实现异步预约下单功能。</p>\n<p>使用阻塞队列也可以完成异步下单的功能，但是会存在几个问题：</p>\n<ol>\n<li>基于 jvm 的阻塞队列存在内存限制的问题</li>\n<li>数据丢失问题：当jvm重启或宕机，阻塞队列中的所有信息都会丢失</li>\n<li>同时，当该订单从阻塞队列中取出后，在处理的过程中发生了异常，则这个订单就永远无法处理了</li>\n</ol>\n<p>因此可以利用 Redis Stream 消息队列解决上面存在的几个问题，Stream类型的消息队列的特点</p>\n<ol>\n<li>消息可回溯</li>\n<li>一个消息可以被多个消费者读取</li>\n<li>可以阻塞读取</li>\n<li>但是有消息漏读的风险</li>\n</ol>\n<p>过程：依然是通过 Lua 脚本进行 判断秒杀优惠券库存和校验一人一单的功能，如果校验成功，则发送消息到消息队列中，并且初始化一个代理对象，这个代理对象可以进行创建订单的功能。</p>\n<p>然后通过一个线程池去不断去消费消息队列中的消息，即使发生异常（消息已取出但未消费）的消息会持久化到PendingList中，后续通过获取pending-list中的订单信息，依然可以将其消费掉。然后跳出 handlePendingList的方法，继续去处理正常的消息队列。最后创建订单，并且通过 SACK 命令确认消息已处理。</p>\n<h3 id=\"探店笔记点赞排行\"><a href=\"#探店笔记点赞排行\" class=\"headerlink\" title=\"探店笔记点赞排行\"></a><strong>探店笔记</strong>点赞排行</h3><p>使用 Redis List 数据结构存储用户点赞信息，并基于 ZSet 实现 TopN 点赞排行</p>\n<h3 id=\"推送点评\"><a href=\"#推送点评\" class=\"headerlink\" title=\"推送点评\"></a>推送点评</h3><p>feed流，使用的是推模式，后续随着用户量的增加，可以将其改为推拉结合，活跃粉丝使用推模式，而普通粉丝则使用拉模式。</p>\n<h3 id=\"附近商户\"><a href=\"#附近商户\" class=\"headerlink\" title=\"附近商户\"></a>附近商户</h3><p>使用了redis中的geo数据结构，根据经纬度坐标信息存储商户的地理位置，并使用 Geo Search 命令实现高性能商户查询及按距离排序。</p>\n<h3 id=\"用户签到\"><a href=\"#用户签到\" class=\"headerlink\" title=\"用户签到\"></a>用户签到</h3><p>使用到了Redis的BitMap数据统计功能，利用bitmap，计算今天是本月的第几天，就将对应bit位置1.</p>\n<p>后续计划根据用户签到送出激励计划，用户签到赠送橙币，可以使用橙币在购买优惠券时抵扣现金。</p>\n",
            "tags": [
                "点评"
            ]
        }
    ]
}